<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>India Orders Heatmap Grid & Stores</title>
 <!-- Leaflet CSS -->
   <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>

    <style>
        /* --- Base Styles --- */
        body { font-family: sans-serif; display: flex; height: 100vh; margin: 0; background-color: #f0f4f8; overflow: hidden; }

        /* --- Left Sidebar --- */
        .sidebar {
            width: 250px; background-color: #fff; padding: 15px; box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; z-index: 1000; height: 100vh; box-sizing: border-box; flex-shrink: 0;
        }
        .sidebar .fixed-container { flex-shrink: 0; }
        .sidebar .scrollable-container {
            flex-grow: 1; overflow-y: auto; margin-bottom: 0; padding-bottom: 15px;
            scrollbar-width: thin; scrollbar-color: #aaa #f0f4f8;
        }
        .sidebar .scrollable-container::-webkit-scrollbar { width: 8px; }
        .sidebar .scrollable-container::-webkit-scrollbar-track { background: #f0f4f8; }
        .sidebar .scrollable-container::-webkit-scrollbar-thumb { background-color: #aaa; border-radius: 4px; }
        .sidebar .fixed-container h2 { margin-top: 0; margin-bottom: 15px; font-size: 1.3em; color: #333; border-bottom: 1px solid #eee; padding-bottom: 10px; font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        /* --- Store Search Styles --- */
        #store-search-input:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25); }
        #store-search-button:hover { background-color: #0056b3; }
        .sidebar h3 { margin-top: 15px; margin-bottom: 8px; font-size: 1.05em; color: #444;}
        .city-list { margin-bottom: 15px; }
        .city-list ul { list-style: none; padding: 0; margin: 0; }
        .city-list li button { display: block; width: 100%; padding: 8px 10px; margin-bottom: 6px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; text-align: left; font-size: 0.9em; transition: background-color 0.2s ease; box-sizing: border-box; word-wrap: break-word; white-space: normal; line-height: 1.3; }
        .city-list li button:hover { background-color: #0056b3; }
        .city-list li button.active { background-color: #e67e22; font-weight: bold; }
        #btn-india-view { background-color: #28a745; font-weight: bold; margin-bottom: 10px; width: 100%; padding: 8px 10px; border: none; border-radius: 4px; cursor: pointer; text-align: center; font-size: 0.9em; color: white; box-sizing: border-box; transition: background-color 0.2s ease;}
        #btn-india-view:hover { background-color: #218838; }
        .controls-bottom { border-top: 1px solid #eee; padding-top: 15px; margin-top: 10px; }
        .controls-bottom .button-row { display: flex; flex-direction: column; gap: 8px; align-items: stretch;}
        #btn-process-data, #btn-erase-data, #btn-analyze-store-coverage, #btn-copy-store-coverage, #btn-generate-test-points, #btn-clear-test-points, #btn-analyze-test-points { /* Added test analysis button */
             padding: 8px 10px; border: none; border-radius: 4px; cursor: pointer; text-align: center; font-size: 0.9em; transition: background-color 0.2s ease, color 0.2s ease, opacity 0.2s ease; color: white; width: 100%; box-sizing: border-box;
        }
        #btn-process-data { background-color: #5bc0de; } /* Copy Grid Values */
        #btn-process-data:hover { background-color: #31b0d5; }
        #btn-process-data:disabled { background-color: #a0a0a0; cursor: default; opacity: 0.7; }
        #btn-erase-data { background-color: #dc3545; } /* Clear Data */
        #btn-erase-data:hover { background-color: #c82333; }
        #btn-erase-data:disabled { background-color: #a0a0a0; cursor: default; opacity: 0.7;}
        #btn-analyze-store-coverage { background-color: #ffc107; color: #212529; } /* Estimate Orders (Real Data) */
        #btn-analyze-store-coverage:hover { background-color: #e0a800; }
        #btn-analyze-store-coverage:disabled { background-color: #a0a0a0; cursor: default; opacity: 0.7;}
        #btn-copy-store-coverage { background-color: #6c757d; margin-top: 10px; } /* Copy Analysis */
        #btn-copy-store-coverage:hover { background-color: #5a6268; }
        #btn-copy-store-coverage:disabled { background-color: #a0a0a0; cursor: default; opacity: 0.7; }
        #btn-generate-test-points { background-color: #ff8c00; } /* Generate Test Points */
        #btn-generate-test-points:hover { background-color: #cc7000; }
        #btn-clear-test-points { background-color: #8a2be2; display: none; } /* Clear Test Points */
        #btn-clear-test-points:hover { background-color: #7324b8; }
        #btn-analyze-test-points { background-color: #32cd32; display: none; } /* Analyze Test Points */
        #btn-analyze-test-points:hover { background-color: #28a428; }
        #btn-analyze-test-points:disabled { background-color: #a0a0a0; cursor: default; opacity: 0.7; }


        /* --- Store Coverage Analysis (Left Sidebar) --- */
        #store-coverage-analysis { margin-top: 15px; padding-top: 15px; border-top: 1px dashed #ccc; }
        #store-coverage-analysis h3 { margin-top: 0; margin-bottom: 8px; font-size: 1.0em; color: #444; font-weight: bold; }
        #store-coverage-table-container { max-height: 200px; overflow-y: auto; margin-bottom: 10px; border: 1px solid #eee; font-size: 0.85em; }
        #store-coverage-table { width: 100%; border-collapse: collapse; table-layout: fixed; }
        #store-coverage-table th, #store-coverage-table td { padding: 3px 5px; border-bottom: 1px solid #f0f0f0; text-align: left; word-wrap: break-word; }
        #store-coverage-table th { background-color: #f8f9fa; font-weight: bold; position: sticky; top: 0; }
        #store-coverage-table th:nth-child(1), #store-coverage-table td:nth-child(1) { width: 18%; text-align: center; } /* Rank */
        #store-coverage-table th:nth-child(2), #store-coverage-table td:nth-child(2) { width: 42%; } /* Store ID / Store ID(s) */
        #store-coverage-table th:nth-child(3), #store-coverage-table td:nth-child(3) { width: 40%; text-align: right;} /* Orders */
        #store-coverage-slider-container { margin-top: 5px; text-align: center; font-size: 0.85em;}
        #store-coverage-slider { width: 80%; margin-top: 5px; cursor: pointer; }
        #store-coverage-analysis .placeholder { color: #888; font-style: italic; font-size: 0.85em; padding: 5px; text-align: center; }

        /* --- Map Container --- */
        .map-container { flex-grow: 1; height: 100vh; position: relative; }
        #map { width: 100%; height: 100%; background-color: #ddd; }
        #loader { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; z-index: 2000; background-color: rgba(255,255,255,0.7); display: none; }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }

        /* --- Right Sidebar --- */
        .right-sidebar {
            width: 220px; background-color: #fff; padding: 15px; box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            z-index: 999; height: 100vh; box-sizing: border-box;
            display: flex; flex-direction: column; flex-shrink: 0;
        }
        .right-sidebar h2 { margin-top: 0; margin-bottom: 15px; font-size: 1.2em; color: #333; flex-shrink: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .right-scrollable-content { flex-grow: 1; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #aaa #f0f4f8; }
        .right-scrollable-content::-webkit-scrollbar { width: 8px; }
        .right-scrollable-content::-webkit-scrollbar-track { background: #f0f4f8; }
        .right-scrollable-content::-webkit-scrollbar-thumb { background-color: #aaa; border-radius: 4px; }
        .right-sidebar .controls-section { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .right-sidebar h3 { margin-top: 10px; margin-bottom: 8px; font-size: 1.0em; color: #444; font-weight: bold;}
        .right-sidebar .toggle-list ul { list-style: none; padding: 0; margin: 0; }
        .right-sidebar .toggle-option { margin-bottom: 5px; position: relative; }
        .right-sidebar .toggle-option input[type="radio"] { opacity: 0; position: absolute; left: -9999px; }
        .right-sidebar .toggle-option label { display: block; text-align: center; width: 100%; box-sizing: border-box; background-color: #6c757d; font-weight: normal; color: #fff; padding: 6px 8px; margin-bottom: 4px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; font-size: 0.85em; }
        .right-sidebar .toggle-option label:hover { background-color: #5a6268; }
        .right-sidebar .toggle-option input[type="radio"]:checked + label { background-color: #17a2b8; font-weight: bold; box-shadow: inset 0 1px 3px rgba(0,0,0,0.2); }
        #analysis-mode-toggle .toggle-option input[type="radio"]:checked + label { background-color: #fd7e14; } /* Orange for active mode */
        #btn-plot-boundaries {
            background-color: #6f42c1; color: white; padding: 8px 10px; border: none; border-radius: 4px; cursor: pointer;
            text-align: center; font-size: 0.9em; transition: background-color 0.2s ease; width: 100%; box-sizing: border-box;
            margin-top: 8px; display: none; /* Hidden by default */
        }
        #btn-plot-boundaries:hover { background-color: #5a349a; }
        #btn-plot-boundaries:disabled { background-color: #a0a0a0; cursor: default; opacity: 0.7; }
        #btn-clear-catchments {
            background-color: #dc3545; color: white; padding: 8px 10px; border: none; border-radius: 4px; cursor: pointer;
            text-align: center; font-size: 0.9em; transition: background-color 0.2s ease; width: 100%; box-sizing: border-box;
            margin-top: 5px; display: none; /* Hidden by default */
        }
        #btn-clear-catchments:hover { background-color: #c82333; }
        #btn-clear-catchments:disabled { background-color: #a0a0a0; cursor: default; opacity: 0.7; }
        .right-sidebar .store-toggle { margin-top: 15px; }
        .right-sidebar .store-toggle label { display: inline-block; width: auto; background-color: #eee; color: #333; padding: 5px 10px; margin-left: 5px; vertical-align: middle; cursor: pointer; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .right-sidebar .store-toggle input[type="checkbox"] { transform: scale(1.2); vertical-align: middle; margin-right: 5px; cursor: pointer; }
        .right-sidebar .store-toggle input[type="checkbox"]:checked + label { background-color: #28a745; color: white; border-color: #218838; font-weight: bold; }
        #retail-legend { margin-top: 10px; font-size: 0.85em; padding: 8px; border: 1px solid #eee; border-radius: 4px; background-color: #fdfdfd; }
        #retail-legend div { margin-bottom: 3px; display: flex; align-items: center; }
        #retail-legend span { height:10px; width:10px; border-radius:50%; display:inline-block; margin-right: 5px; border: 1px solid #ccc; flex-shrink: 0; }
        .right-sidebar .centroid-toggle { margin-top: 10px; }
        .right-sidebar .centroid-button { display: block; text-align: center; width: 100%; box-sizing: border-box; background-color: #6c757d; font-weight: normal; color: #fff; padding: 6px 8px; margin-bottom: 4px; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease; font-size: 0.85em; }
        .right-sidebar .centroid-button:hover { background-color: #5a6268; }
        .right-sidebar .centroid-button.active { background-color: #000000; font-weight: bold; box-shadow: inset 0 1px 3px rgba(255,255,255,0.2); }
        .right-sidebar .centroid-button:disabled { background-color: #a0a0a0; cursor: default; opacity: 0.7; }
        #grid-summary-container { padding-top: 15px; }
        #grid-summary-container h3 { margin: 0 0 8px 0; font-size: 1.0em; color: #444; font-weight: bold;}
        #grid-summary-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        #grid-summary-table td { padding: 4px 5px; border: 1px solid #e0e0e0; text-align: left;}
        #grid-summary-table td:first-child { font-weight: bold; color: #555; width: 45%; }
        #grid-summary-table td:last-child { text-align: right; color: #333; }
        #grid-summary-container .placeholder { color: #888; font-style: italic; font-size: 0.85em; padding: 5px; }

        /* Grid label style */
        .grid-label { background-color: rgba(255, 255, 255, 0.85); color: #333; border: none; box-shadow: none; border-radius: 3px; padding: 1px 4px; font-size: 9px; font-weight: bold; white-space: nowrap; user-select: text; }

       
    </style>
</head>
<body>

    <!-- Left Sidebar -->
    <div class="sidebar">
         <div class="fixed-container">
             <h2>India Overview</h2>

             <!-- *** NEW Store Search *** -->
             <div id="store-search-container" style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
                 <input type="text" id="store-search-input" placeholder="Search Store ID..." style="width: calc(100% - 65px); padding: 6px 8px; border: 1px solid #ccc; border-radius: 4px 0 0 4px; font-size: 0.9em; box-sizing: border-box; vertical-align: middle;">
                 <button id="store-search-button" style="width: 60px; padding: 6px 8px; background-color: #007bff; color: white; border: none; border-radius: 0 4px 4px 0; cursor: pointer; font-size: 0.9em; vertical-align: middle; transition: background-color 0.2s ease;">Go</button>
                 <div id="store-search-feedback" style="font-size: 0.8em; color: #dc3545; margin-top: 4px; min-height: 1.2em;"></div>
             </div>
             <!-- *** END Store Search *** -->

             <button id="btn-india-view">India (Overview)</button>
             <h3>Zoom to City</h3>
         </div>
         <div class="scrollable-container">
             <div class="city-list">
                <ul>
                     <li><button data-city="jaipur" data-lat="26.9124" data-lng="75.7873">Jaipur</button></li>
                </ul>
             </div>
             <div class="controls-bottom">
                 <div class="button-row">
                     <button id="btn-process-data" disabled>Copy Grid Values</button>
                     <button id="btn-analyze-store-coverage" disabled>Estimate Orders (Real Data)</button> <!-- Clarified button text -->
                     <button id="btn-erase-data">Clear Data</button>
                     <!-- Test Point Buttons -->
                     <button id="btn-generate-test-points">Generate 100 Test Points (Value=1)</button>
                     <button id="btn-analyze-test-points" style="display: none;">Analyze Test Points</button> <!-- NEW -->
                     <button id="btn-clear-test-points" style="display: none;">Clear Test Points</button>
                 </div>
                 <div id="store-coverage-analysis" style="display: none;">
                     <h3 id="analysis-results-title">Analysis Results</h3>
                     <div id="store-coverage-table-container">
                          <div class="placeholder">Run analysis first...</div>
                     </div>
                     <div id="store-coverage-slider-container">
                         <label for="store-coverage-slider">Show Top <span id="store-coverage-slider-label">0</span> Items:</label><br>
                         <input type="range" id="store-coverage-slider" min="0" max="0" value="0" step="1" disabled>
                     </div>
                     <button id="btn-copy-store-coverage" disabled>Copy Analysis Data</button>
                 </div>
             </div>
         </div>
    </div>

    <!-- Map Container -->
    <div class="map-container">
        <div id="map"></div>
        <div id="loader"></div>
    </div>

    <!-- Right Sidebar -->
    <div class="right-sidebar">
        <h2>Controls</h2>
        <div class="right-scrollable-content">
             <!-- Analysis Mode Toggle -->
             <div class="controls-section" id="analysis-mode-toggle">
                <h3>Analysis Mode</h3>
                <div class="toggle-list">
                    <ul>
                        <li class="toggle-option"><input type="radio" id="mode-grid" name="analysis-mode-toggle" value="grid" checked><label for="mode-grid">Grid Mode</label></li>
                        <li class="toggle-option"><input type="radio" id="mode-boundary" name="analysis-mode-toggle" value="boundary"><label for="mode-boundary">Boundary Mode</label></li>
                    </ul>
                 </div>
                 <button id="btn-plot-boundaries">Plot Boundaries</button>
                 <button id="btn-clear-catchments">Clear Catchments</button>
             </div>
             <!-- Catchment Size (Used by both modes) -->
            <div class="controls-section" id="catchment-controls">
                <h3>Catchment Size</h3>
                <div id="catchment-radio-group" class="toggle-list">
                    <ul>
                        <li class="toggle-option"><input type="radio" id="grid-none" name="grid-toggle" value="none" checked><label for="grid-none">None</label></li>
                        <li class="toggle-option"><input type="radio" id="grid-1km" name="grid-toggle" value="1km"><label for="grid-1km">15min Catchment</label></li>
                        <li class="toggle-option"><input type="radio" id="grid-4km" name="grid-toggle" value="4km"><label for="grid-4km">30min Catchment</label></li>
                        <li class="toggle-option"><input type="radio" id="grid-8km" name="grid-toggle" value="8km"><label for="grid-8km">60min Catchment</label></li>
<li class="toggle-option">
  <input type="radio" id="grid-heatmap" name="grid-toggle" value="heatmap">
  <label for="grid-heatmap">Real Heatmap</label>
</li>

                    </ul>
                 </div>
                 <div id="boundary-catchment-checkboxes" class="store-toggle" style="display:none; margin-top:10px;">
                   <label><input type="checkbox" value="1km" class="catchment-checkbox"> 15min Catchment</label>
                   <label><input type="checkbox" value="4km" class="catchment-checkbox"> 30min Catchment</label>
                   <label><input type="checkbox" value="8km" class="catchment-checkbox"> 60min Catchment</label>
  <label><input type="checkbox" value="heatmap" class="catchment-checkbox"> Real Heatmap</label>
                 </div>
            </div>
             <!-- Heatmap Gradient (Grid Mode Only) -->
            <div class="controls-section" id="heatmap-controls">
                 <h3>Heat Map Gradient</h3>
                 <div class="toggle-list">
                     <ul>
                         <li class="toggle-option"><input type="radio" id="scale-3" name="color-scale-toggle" value="3"><label for="scale-3">0 - 3</label></li>
                         <li class="toggle-option"><input type="radio" id="scale-5" name="color-scale-toggle" value="5"><label for="scale-5">0 - 5</label></li>
                         <li class="toggle-option"><input type="radio" id="scale-10" name="color-scale-toggle" value="10"><label for="scale-10">0 - 10</label></li>
                         <li class="toggle-option"><input type="radio" id="scale-15" name="color-scale-toggle" value="15" checked><label for="scale-15">0 - 15</label></li>
                         <li class="toggle-option"><input type="radio" id="scale-20" name="color-scale-toggle" value="20"><label for="scale-20">0 - 20</label></li>
                     </ul>
                  </div>
            </div>
            <!-- ADs Locations -->
<div class="controls-section" id="ads-toggle-section">
  <h3>ADs Types</h3>
  <div class="store-toggle">
    <!-- Checkboxes are initially checked in HTML and then their state is set by JS in initApp -->
    <label><input type="checkbox" id="toggle-atl" checked> ATL</label>
    <label><input type="checkbox" id="toggle-facade" checked> FC</label>
    <label><input type="checkbox" id="toggle-banner" checked> RetailStore</label>
  </div>
</div>
  <!-- ===== INSERT HERE ===== -->
  <!-- Retail‐Store Toggle List -->
  <div id="store-toggle-container"
       style="margin-top:1em; padding-top:1em; border-top:1px solid #ccc;">
    <h4 style="margin-bottom:0.5em; font-size:1rem;">Retail Store Visibility</h4>
    <!-- JS will populate individual checkboxes here -->
  </div>


                 <div id="retail-legend" style="display: none;">
    <div><span style="background-color:Yellow;"></span> ATL</div>
    <div><span style="background-color:blue;"></span> FC</div>
    <div><span style="background-color:green;"></span> RetailStore</div>
</div>

             </div>
             <!-- Grid Cell Analysis (Grid Mode Only) -->
            <div class="controls-section" id="grid-analysis-controls">
                <h3 style="margin-top: 15px;">Grid Cell Analysis</h3>
                <div class="centroid-toggle">
                    <button id="btn-toggle-centroids" class="centroid-button">Show Cell Centroids</button>
                </div>
            </div>
             <!-- Grid Summary (Grid Mode Only) -->
            <div id="grid-summary-container">
                 <div class="placeholder">Summary data will appear here...</div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

    <script>
        // --- Configuration & Constants ---
        const INDIA_CENTER = [22.5, 82.0];
        const INDIA_ZOOM = 5;
        const INITIAL_ZOOM = INDIA_ZOOM;
        const CITY_ZOOM = 12;
        const FLY_DURATION = 1.0;
        const GRID_TOOLTIP_THRESHOLD = 1.0;
        const GRID_1KM_THRESHOLD = 0.1;
        const RETAIL_MARKER_RADIUS = 5;
        const HIGHLIGHT_CELL_STYLE = { color: 'yellow', weight: 2, opacity: 0.9, fillOpacity: 0.1 };
        const BLINKING_BOUNDARY_STYLE = { color: '#000000', weight: 2.5, opacity: 1, fillOpacity: 0, dashArray: '5, 5', interactive: false };
        const TEST_POINT_OPTIONS = { radius: 4, fillColor: "#8B0000", color: "#8B0000", weight: 1, opacity: 1, fillOpacity: 0.9 }; // Deep Red, slightly larger radius

        // --- Global State Variables ---
        let currentAnalysisMode = 'grid';
        let currentMaxColorValue = 15;
        let activeGridLayer = null;
        let currentGridSize = 'none';
	    let heatmapLayer = null;
        let currentCityFilter = null;
        // Layers for specific AD types
        let atlLayer = L.layerGroup();
        let facadeLayer = L.layerGroup();
        let bannerLayer = L.layerGroup();
        // Combined layer for search functionality (all retail markers, regardless of type)
        let allRetailMarkersLayer = L.layerGroup(); // NEW: A single layer to hold all retail markers for easy searching
	        // ===== INSERT HERE =====
        // Dictionary to keep each retail‐store marker by its storeId
        const retailStoreMarkers = {};

        let isStoreDataLoaded = false; // Flag to indicate if retail store data has been processed
        let currentGridValues = [];
        let needsGridRegeneration = false;
        let isRegenerationInProgress = false;
        let canonicalView = { lat: INDIA_CENTER[0], lng: INDIA_CENTER[1], zoom: INDIA_ZOOM };
        let centroidLayer = L.layerGroup();
        let areCentroidsVisible = false;
        const CENTROID_MARKER_OPTIONS = { radius: 3, fillColor: "#000000", color: "#000000", weight: 1, opacity: 1, fillOpacity: 0.9 };
        let coveredGridCellsData = [];
        let boundaryAnalysisResults = [];
        let highlightedGridLayer = L.featureGroup();
        let storeClickBoundaryLayer = L.featureGroup();
        let boundaryLayer = L.featureGroup();
        let testDataPoints = [];
        let testPointsLayer = L.layerGroup();
        let isShowingTestResults = false; // Flag to track if analysis table shows test results


        // --- DATA INPUT ---
        // !!! Keep your actual data here !!!
        const actualDataPoints = [{lat:18.5982843, lng:73.7790416, orders: 0.0088585728839084, city:"Jaipur"},
{lat:21.5553503, lng:79.2451148999999, orders: 0.0088585728839084, city:"Jaipur"},
{lat:31.6313339, lng:76.9410799, orders: 0.0044292864419542, city:"Jaipur"}];

        console.log(`Actual Data loaded: ${actualDataPoints.length} points`);
        const retailStoreData = [
      { storeId: "1MG_HKR",lat: 26.96137783,lng: 75.69635806, type:"RetailStore" },
{ storeId: "1MG_BPN",lat: 26.89027179,lng: 75.80967699, type:"RetailStore" },
{ storeId: "1MG_ANS",lat: 26.91185931,lng: 75.82435744, type:"RetailStore" },
{ storeId: "1MG_GLB",lat: 26.81036092,lng: 75.80905811, type:"RetailStore" },
{ storeId: "1MG_GPP",lat: 26.86983116,lng: 75.78018336, type:"RetailStore" },
{ storeId: "1MG_JGT",lat: 26.83338943,lng: 75.81578004, type:"RetailStore" },
{ storeId: "1MG_JMN",lat: 26.84688,lng: 75.80888, type:"RetailStore" },
{ storeId: "1MG_JPT",lat: 26.89405767,lng: 75.76594849, type:"RetailStore" },
{ storeId: "1MG_LAL",lat: 26.90183027,lng: 75.71695891, type:"RetailStore" },
{ storeId: "1MG_MVI",lat: 26.86136921,lng: 75.74295829, type:"RetailStore" },
{ storeId: "1MG_MVN",lat: 26.85504685,lng: 75.81337248, type:"RetailStore" },
{ storeId: "1MG_NRN",lat: 26.88645207,lng: 75.7515268, type:"RetailStore" },
{ storeId: "1MG_PTN",lat: 26.90172473,lng: 75.78599492, type:"RetailStore" },
{ storeId: "1MGR_DG",lat: 26.85156,lng: 75.78354, type:"RetailStore" },
{ storeId: "1MGR_JR",lat: 26.89751,lng: 75.82219, type:"RetailStore" },
{ storeId: "1MGR_JW",lat: 26.89482,lng: 75.83695, type:"RetailStore" },
{ storeId: "1MGR_SH",lat: 26.93711,lng: 75.79545, type:"RetailStore" },
{ storeId: "1MGR_SY",lat: 26.89024,lng: 75.76999, type:"RetailStore" },
{ storeId: "1MGR_SR",lat: 26.9208,lng: 75.73445, type:"RetailStore" },
{ storeId: "1MG_VHN",lat: 26.90220709,lng: 75.75385346, type:"RetailStore" },
{ storeId: "1MG_VPM",lat: 26.84790622,lng: 75.76980309, type:"RetailStore" },
{ storeId: "1MG_GRN",lat: 26.83877799,lng: 75.76255263, type:"RetailStore" },
{ storeId: "1MG_JAI",lat: 26.98052,lng: 75.7794, type:"FC" },
{ storeId: "1MG_SWP",lat: 26.87251787,lng: 75.75839086, type:"RetailStore" },
{ storeId: "1MG_VSN",lat: 26.9112818,lng: 75.74244989, type:"RetailStore" },
{ storeId: "1MG_CKS",lat: 26.90498,lng: 75.73365, type:"RetailStore" }

        ];
        console.log(`Retail/FC/New/BBNow Data loaded: ${retailStoreData.length} points`);


        // --- Map Initialization ---
        const map = L.map('map', { zoomSnap: 0.25, zoomDelta: 0.25, }).setView(INDIA_CENTER, INITIAL_ZOOM);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }).addTo(map);
        storeClickBoundaryLayer.addTo(map); highlightedGridLayer.addTo(map); boundaryLayer.addTo(map);
        testPointsLayer.addTo(map);

        // Add AD type layers to map by default (based on initial checkbox state)
        map.addLayer(atlLayer);
        map.addLayer(facadeLayer);
        map.addLayer(bannerLayer);
        // Add the combined layer for search (it doesn't need to be added/removed, just used for searching)
        allRetailMarkersLayer.addTo(map);


        // --- UI Elements ---
        const sidebarTitle = document.querySelector('.sidebar .fixed-container h2');
        const storeSearchInput = document.getElementById('store-search-input');          // NEW
        const storeSearchButton = document.getElementById('store-search-button');        // NEW
        const storeSearchFeedback = document.getElementById('store-search-feedback');      // NEW
        const cityButtons = document.querySelectorAll('.city-list li button');
        const indiaViewButton = document.getElementById('btn-india-view');
        const processDataButton = document.getElementById('btn-process-data');
        const eraseDataButton = document.getElementById('btn-erase-data');
        const loader = document.getElementById('loader');
        const analysisModeRadios = document.querySelectorAll('input[name="analysis-mode-toggle"]');
        const plotBoundariesButton = document.getElementById('btn-plot-boundaries');
        const clearCatchmentsButton = document.getElementById('btn-clear-catchments');
        const gridToggleRadios = document.querySelectorAll('input[name="grid-toggle"]');
        const colorScaleRadios = document.querySelectorAll('input[name="color-scale-toggle"]');
        const gridSummaryContainer = document.getElementById('grid-summary-container');
        // const retailToggleCheckbox = document.getElementById('toggle-retail-stores'); // REMOVED - not in HTML
        const atlCheckbox = document.getElementById('toggle-atl'); // NEW
        const facadeCheckbox = document.getElementById('toggle-facade'); // NEW
        const bannerCheckbox = document.getElementById('toggle-banner'); // NEW
        const retailLegend = document.getElementById('retail-legend');
        const centroidToggleButton = document.getElementById('btn-toggle-centroids');
        const placeholderSummary = '<div class="placeholder">Summary data will appear here...</div>';
        const analyzeStoreCoverageButton = document.getElementById('btn-analyze-store-coverage');
        const storeCoverageAnalysisDiv = document.getElementById('store-coverage-analysis');
        const storeCoverageTableContainer = document.getElementById('store-coverage-table-container');
        const storeCoverageSlider = document.getElementById('store-coverage-slider');
        const storeCoverageSliderLabel = document.getElementById('store-coverage-slider-label');
        const storeCoveragePlaceholder = '<div class="placeholder">Run analysis first...</div>';
        const copyStoreCoverageButton = document.getElementById('btn-copy-store-coverage');
        const analysisResultsTitle = document.getElementById('analysis-results-title');
        const catchmentControls = document.getElementById('catchment-controls');
        const catchmentRadioGroup = document.getElementById('catchment-radio-group');
        const boundaryCatchmentContainer = document.getElementById('boundary-catchment-checkboxes');
        const boundaryCatchmentCheckboxes = boundaryCatchmentContainer.querySelectorAll('input[type="checkbox"]');
        const heatmapControls = document.getElementById('heatmap-controls');
        const gridAnalysisControls = document.getElementById('grid-analysis-controls');
        const storeCoverageSliderContainer = document.getElementById('store-coverage-slider-container');
        const generateTestPointsButton = document.getElementById('btn-generate-test-points');
        const clearTestPointsButton = document.getElementById('btn-clear-test-points');
        const analyzeTestPointsButton = document.getElementById('btn-analyze-test-points');


        // --- Helper Functions ---
        function getDegChange(km, latitude) { const latDegPerKm = 1 / 111.32; const effectiveLat = Math.max(-85, Math.min(85, latitude)); const cosLat = Math.cos(effectiveLat * Math.PI / 180); const lngDegPerKm = (cosLat > 1e-9) ? (1 / (111.32 * cosLat)) : (1 / (111.32 * 1e-9)); return { latDelta: km * latDegPerKm, lngDelta: km * lngDegPerKm }; }
function getOrderColor(value, maxColorValue) {
    if (value <= 0) return "#ffffff";
    
    const cappedValue = Math.min(value, maxColorValue);
    const maxValue = Math.max(0.00001, maxColorValue);
    const ratio = Math.max(0, Math.min(1, cappedValue / maxValue));

    let r, g, b;

    if (ratio <= 0.5) {
        // Interpolate between White (#ffffff) and Yellow (#ffff00)
        const t = ratio / 0.5; // Normalize to 0–1 range
        r = 255;
        g = 255;
        b = Math.round(255 * (1 - t));
    } else {
        // Interpolate between Yellow (#ffff00) and Red (#ff0000)
        const t = (ratio - 0.5) / 0.5;
        r = 255;
        g = Math.round(255 * (1 - t));
        b = 0;
    }

    const toHex = c => c.toString(16).padStart(2, '0');
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

        function showLoader(show) { loader.style.display = show ? 'block' : 'none'; }
        function getAllDataPoints() { return [...actualDataPoints, ...testDataPoints]; }

        // NEW: Function to check if any AD type layer is visible
        function areAnyADLayersVisibleAndLoaded() {
            return (atlCheckbox.checked && atlLayer.getLayers().length > 0) ||
                   (facadeCheckbox.checked && facadeLayer.getLayers().length > 0) ||
                   (bannerCheckbox.checked && bannerLayer.getLayers().length > 0);
        }

        // --- NEW: Store Search Function ---
        function findAndHighlightStore() {
            const searchTerm = storeSearchInput.value.trim();
            storeSearchFeedback.textContent = ''; // Clear previous feedback
            storeSearchFeedback.style.color = '#dc3545'; // Default to error color

            if (!searchTerm) {
                storeSearchFeedback.textContent = 'Please enter a Store ID.';
                return;
            }

            if (!isStoreDataLoaded) { // Check if data has been loaded/processed once
                storeSearchFeedback.textContent = 'Store data not yet loaded. Please wait or refresh.';
                return;
            }
            
            // Check if any AD layer is checked. If not, prompt user.
            if (!areAnyADLayersVisibleAndLoaded()) {
                storeSearchFeedback.textContent = 'Enable at least one AD Type checkbox first.';
                return;
            }


            let foundMarker = null;
            const searchTermLower = searchTerm.toLowerCase(); // Case-insensitive search

            // Iterate over the combined layer of all retail markers for search
            allRetailMarkersLayer.eachLayer(marker => { // Now this layer actually contains markers
                if (marker.storeData && marker.storeData.storeId && marker.storeData.storeId.toLowerCase() === searchTermLower) {
                    foundMarker = marker;
                    // In a real scenario with many markers, you might optimize by breaking early
                    // but for Leaflet's eachLayer, it's generally fine.
                }
            });

            if (foundMarker) {
                const latLng = foundMarker.getLatLng();
                const zoomLevel = Math.max(map.getZoom(), 15); // Zoom in if needed, but don't zoom out too much

                map.flyTo(latLng, zoomLevel, {
                    animate: true,
                    duration: FLY_DURATION // Use existing constant
                });

                // Blinking effect using CSS
                const markerIcon = foundMarker.getElement();
                if (markerIcon) {
                    // Remove class first to restart animation if marker is clicked again quickly
                    markerIcon.classList.remove('marker-blink');
                     // Force reflow/repaint before adding class again - crucial for restarting animation
                    void markerIcon.offsetWidth;

                    markerIcon.classList.add('marker-blink');
                    // Remove the class after the animation completes (5 cycles * 0.5s = 2.5s)
                    setTimeout(() => {
                        // Check if the class is still present before removing
                        if (markerIcon.classList.contains('marker-blink')) {
                           markerIcon.classList.remove('marker-blink');
                        }
                    }, 2600); // Slightly longer than animation duration
                    storeSearchFeedback.textContent = `Found: ${foundMarker.storeData.storeId}`;
                    storeSearchFeedback.style.color = '#28a745'; // Green for success
                } else {
                    console.warn("Could not get marker element for blinking.");
                    storeSearchFeedback.textContent = 'Store found, but cannot blink marker.';
                    storeSearchFeedback.style.color = '#ffc107'; // Yellow for warning
                }
                 // Clear input after successful search - uncomment if desired
                // storeSearchInput.value = '';
            } else {
                storeSearchFeedback.textContent = `Store ID "${searchTerm}" not found.`;
                storeSearchFeedback.style.color = '#dc3545'; // Red for error
            }
        }

        // --- Test Point Generation / Clearing ---
        function generateTestPoints() {
            clearTestPoints(); console.log("Generating 100 test points within current view..."); showLoader(true);
            const bounds = map.getBounds(); const southWest = bounds.getSouthWest(); const northEast = bounds.getNorthEast(); const numPoints = 100; const testOrderValue = 1;
            if (!bounds.isValid()) { alert("Cannot generate test points: Map bounds are invalid."); showLoader(false); return; }
            for (let i = 0; i < numPoints; i++) {
                const lat = southWest.lat + Math.random() * (northEast.lat - southWest.lat); const lng = southWest.lng + Math.random() * (northEast.lng - southWest.lng);
                const testPoint = { lat: lat, lng: lng, orders: testOrderValue, isTestPoint: true }; testDataPoints.push(testPoint);
                const marker = L.circleMarker([lat, lng], TEST_POINT_OPTIONS); marker.bindTooltip(`Test Point #${i + 1}<br>Value: ${testOrderValue}`); testPointsLayer.addLayer(marker);
            }
            if (!map.hasLayer(testPointsLayer)) testPointsLayer.addTo(map);
            clearTestPointsButton.style.display = 'block';
            analyzeTestPointsButton.style.display = 'block'; // Show Analyze Test button
            analyzeTestPointsButton.disabled = false;        // Enable Analyze Test button
            showLoader(false); console.log(`Generated ${testDataPoints.length} test points.`);
            alert(`${testDataPoints.length} dark red test points (each with order value 1) added to the current view. Run analysis again or use 'Analyze Test Points'.`);
            clearAnalysisResults();
        }
        function clearTestPoints() {
            if (testDataPoints.length > 0) {
                console.log("Clearing test points..."); testDataPoints = []; testPointsLayer.clearLayers();
                clearTestPointsButton.style.display = 'none';
                analyzeTestPointsButton.style.display = 'none'; // Hide Analyze Test button
                analyzeTestPointsButton.disabled = true;       // Disable Analyze Test button
                console.log("Test points cleared."); clearAnalysisResults();
            }
        }


        // --- Grid Generation (Grid Mode Only) ---
async function generateGridLayer(gridSizeKm) {
    // If we're not in “grid” mode, bail out immediately
    if (currentAnalysisMode !== 'grid') {
        return { layer: L.featureGroup(), data: [] };
    }

    const threshold = (currentGridSize === '1km')
        ? GRID_1KM_THRESHOLD
        : GRID_TOOLTIP_THRESHOLD;
    const filterInfo = currentCityFilter
        ? `filtered by "${currentCityFilter}"`
        : "unfiltered";
    console.log(`DEBUG: generateGridLayer START ${gridSizeKm}km (${filterInfo})`);

    return new Promise((resolve) => {
        showLoader(true);

        try {
            const newGridLayer = L.featureGroup();
            const calculatedValues = [];

            const bounds = map.getBounds().pad(0.1);
            const southWest = bounds.getSouthWest();
            const northEast = bounds.getNorthEast();
            const center = map.getCenter();
            const centerLat = center.lat;

            // Basic sanity checks on map state
            if (
                !southWest ||
                !northEast ||
                !center ||
                isNaN(centerLat) ||
                Math.abs(centerLat) > 85
            ) {
                console.warn("Invalid map state for grid generation.");
                showLoader(false);
                resolve({ layer: L.featureGroup(), data: [] });
                return;
            }

            // Compute lat/lng “delta” in degrees for the given km
            const { latDelta, lngDelta } = getDegChange(gridSizeKm, centerLat);
            if (
                !isFinite(latDelta) ||
                !isFinite(lngDelta) ||
                latDelta <= 0 ||
                lngDelta <= 0
            ) {
                console.warn("Invalid grid delta calculated.");
                showLoader(false);
                resolve({ layer: L.featureGroup(), data: [] });
                return;
            }

            // Prepare to accumulate grid‐cell statistics
            let totalCellsCalculated = 0;
            let totalCellsAdded = 0;

            // “Round down” the SW corner to the nearest multiple of delta, then step one extra delta
            const startLat = Math.fround(
                Math.floor(southWest.lat / latDelta) * latDelta - latDelta
            );
            const startLng = Math.fround(
                Math.floor(southWest.lng / lngDelta) * lngDelta - lngDelta
            );

            // “Round up” the NE corner to the nearest multiple of delta, then add one delta
            const endLat = Math.fround(
                Math.ceil(northEast.lat / latDelta) * latDelta + latDelta
            );
            const endLng = Math.fround(
                Math.ceil(northEast.lng / lngDelta) * lngDelta + lngDelta
            );

            // Gather all data points (filtered by city/test‐points if needed)
            const allPoints = getAllDataPoints();
            let pointsToProcess = allPoints.filter(p =>
                p &&
                typeof p.lat === 'number' &&
                typeof p.lng === 'number' &&
                !isNaN(p.lat) &&
                !isNaN(p.lng) &&
                (
                    currentCityFilter === null ||
                    (p.city && p.city.toUpperCase() === currentCityFilter) ||
                    p.isTestPoint
                )
            );

            // Safeguard against runaway loops
            let loopCount = 0;
            const MAX_LOOP_ITERATIONS = 200000;

            // Iterate over each “cell” in the grid
            for (let lat = startLat; lat < endLat; lat += latDelta) {
                if (latDelta <= 0 || loopCount > MAX_LOOP_ITERATIONS) break;

                for (let lng = startLng; lng < endLng; lng += lngDelta) {
                    loopCount++;
                    if (lngDelta <= 0 || loopCount > MAX_LOOP_ITERATIONS) break;

                    totalCellsCalculated++;

                    const cellLatMax = lat + latDelta;
                    const cellLngMax = lng + lngDelta;
                    const cellBounds = [[lat, lng], [cellLatMax, cellLngMax]];

                    // Sum up “orders” for all points inside this cell
                    let sumOrders = 0;
                    for (const point of pointsToProcess) {
                        if (
                            typeof point.orders === 'number' &&
                            !isNaN(point.orders) &&
                            point.lat >= lat &&
                            point.lat < cellLatMax &&
                            point.lng >= lng &&
                            point.lng < cellLngMax
                        ) {
                            sumOrders += point.orders;
                        }
                    }

                    // Decide whether to draw this cell based on threshold
                    const shouldAddCell = (currentGridSize === '1km')
                        ? (sumOrders >= threshold)
                        : (sumOrders > threshold);

                    if (shouldAddCell) {
                        totalCellsAdded++;
                        calculatedValues.push(sumOrders);

                        const color = getOrderColor(sumOrders, currentMaxColorValue);
                        const rect = L.rectangle(cellBounds, {
                            stroke: true,
                            weight: 0.5,
                            color: '#cccccc',
                            fillColor: color,
                            fillOpacity: 0.7
                        });

                        // Tooltip shows the order count; always‐visible when zoom level > 13
                        const displayValue = sumOrders.toFixed(
                            sumOrders < 10 ? 2
                            : sumOrders < 100 ? 1
                            : 0
                        );
                        rect.bindTooltip(displayValue, {
                            permanent: map.getZoom() > 13,
                            direction: 'center',
                            className: 'grid-label',
                            opacity: 0.9
                        });

                        // Store the raw order value on the rectangle for any future use
                        rect._orderValue = sumOrders;
                        newGridLayer.addLayer(rect);
                    }
                }
            }

            if (loopCount > MAX_LOOP_ITERATIONS) {
                console.warn("Grid generation loop exceeded maximum iterations.");
            }

            showLoader(false);
            console.log(
                `Grid Generation Complete: Calculated ${totalCellsCalculated}, Added ${totalCellsAdded} cells.`
            );
            resolve({ layer: newGridLayer, data: calculatedValues });

        } catch (error) {
            console.error("Error generating grid:", error);
            showLoader(false);
            resolve({ layer: L.featureGroup(), data: [] });
        }
    });
}


function showHeatmapLayer() {
    if (heatmapLayer) {
        map.removeLayer(heatmapLayer);
    }

    const heatPoints = actualDataPoints.map(p => [
        p.lat,
        p.lng,
        Math.min(1, p.orders * 2000)  // reduced from 3000
    ]);

    heatmapLayer = L.heatLayer(heatPoints, {
        radius: 12,       // smaller = sharper detail
        blur: 10,         // less blur = less smudge
        maxZoom: 16,
        gradient: {
            0.0: 'transparent',
            0.2: '#ffe6e6',
            0.4: '#ff9999',
            0.6: '#ff4d4d',
            1.0: '#b30000'   // dark but not pitch red
        }
    }).addTo(map);
}

        // --- Retail Store Marker Creation ---
        function createRetailStoreMarkers() {
            // Clear all AD specific layers and the combined layer
            atlLayer.clearLayers();
            facadeLayer.clearLayers();
            bannerLayer.clearLayers();
            allRetailMarkersLayer.clearLayers(); // Clear combined layer too

            let addedCount = 0;
            retailStoreData.forEach(data => {
                if (!data || typeof data.lat !== 'number' || typeof data.lng !== 'number' || isNaN(data.lat) || isNaN(data.lng) || !data.storeId || (Math.abs(data.lat) < 0.001 && Math.abs(data.lng) < 0.001)) {
                    console.warn("Skipping invalid store data:", data);
                    return;
                }
                let color;
               const typeLower = (data.type || '').toLowerCase();
switch (typeLower) {
  case 'atl':
      color = 'yellow';
      break;
  case 'fc':
  case 'gate facade':
      color = 'blue';
      break;
  case 'retailstore':
      color = 'green';
      break;
  default:
      color = 'grey';
      break;
}


                const marker = L.circleMarker([data.lat, data.lng], {
                    radius: RETAIL_MARKER_RADIUS,
                    fillColor: color,
                    color: color,
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                });
                marker.bindTooltip(`<b>${data.storeId}</b><br>${data.type || 'Unknown Type'}`);
                marker.storeData = data; // Attach original data for later use (e.g., search)
		        // ===== INSERT HERE =====
        // Keep a reference to each retail‐store marker by storeId
        retailStoreMarkers[data.storeId] = marker;

                marker.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    handleStoreMarkerClick(e.target);
                });

                // Add to specific type layer
               if (typeLower === 'atl') {
  atlLayer.addLayer(marker);
} else if (typeLower === 'fc' || typeLower === 'gate facade') {
  facadeLayer.addLayer(marker);
} else if (typeLower === 'retailstore') {
  bannerLayer.addLayer(marker);
}
allRetailMarkersLayer.addLayer(marker);


                addedCount++;
            });
            console.log(`Created ${addedCount} store/FC/New/BBNow markers.`);
            isStoreDataLoaded = true; // Mark data as loaded
            updateADLayerVisibility(); // Ensure initial visibility and legend are correct
	            // ===== INSERT HERE =====
        // Once retail‐store markers are in place, build the per‐store toggle list
        initStoreToggleList();

	

            updateAnalysisButtonStates(); // Update button states after stores are loaded
        }

// ===== INSERT HERE =====
// Build a checkbox under #store-toggle-container for every storeId
// ===== INSERT HERE =====
// Build a checkbox under #store-toggle-container for every storeId
// ===== INSERT HERE =====
// Build a checkbox under #store-toggle-container for every storeId
function initStoreToggleList() {
  const container = document.getElementById('store-toggle-container');
  if (!container) return; // In case HTML was not loaded

  retailStoreData.forEach(data => {
    // Create a <label> that wraps a <checkbox> + the storeId text
    const label = document.createElement('label');
    label.style.display = 'block';
    label.style.marginBottom = '0.4em';
    label.style.cursor = 'pointer';

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = true;
    checkbox.id = `toggle-${data.storeId}`;

    // When toggled, remove or re-add the corresponding circleMarker & its boundaries
checkbox.addEventListener('change', (e) => {
  const isChecked = e.target.checked;
  const sid = data.storeId;
  const marker = retailStoreMarkers[sid];

  if (marker) {
    if (isChecked) {
      // Re-add this store marker to bannerLayer if it was removed
      if (!bannerLayer.hasLayer(marker)) {
        bannerLayer.addLayer(marker);
      }
    } else {
      // ——— Remove this store’s marker ———
      if (bannerLayer.hasLayer(marker)) {
        bannerLayer.removeLayer(marker);
      }

      // ——— Remove any single-click boundary tagged with this storeId ———
      storeClickBoundaryLayer.eachLayer(layer => {
        if (layer.storeId === sid) {
          storeClickBoundaryLayer.removeLayer(layer);
        }
      });

      // ——— (gridBoundaryLayer loop removed) ———

      // ——— ALSO remove any “Plot Boundaries” rectangle tagged with this storeId ———
      boundaryLayer.eachLayer(layer => {
        if (layer.storeId === sid) {
          boundaryLayer.removeLayer(layer);
        }
      });
    }
  }
});

// Label text is the storeId
label.appendChild(checkbox);
label.appendChild(document.createTextNode(` ${data.storeId}`));
container.appendChild(label);
});      // <-- closes data.forEach(…)
  }    

 // --- Single Store Click Boundary ---
function handleStoreMarkerClick(marker) {
    // Only draw a single boundary when in Boundary mode
    const selectedMode = document.querySelector('input[name="analysis-mode-toggle"]:checked')?.value;
    if (selectedMode !== 'boundary') return;  // ← Legal, because we are inside a function

    clearStoreClickBoundary(); // Clear previous boundary first
    const selectedCatchmentSize = document.querySelector('input[name="grid-toggle"]:checked')?.value;
    if (!selectedCatchmentSize || selectedCatchmentSize === 'none') {
        storeSearchFeedback.textContent = 'Select a catchment size first.';
        storeSearchFeedback.style.color = '#ffc107'; // Yellow warning
        return;  // ← Also legal inside the function
    }

    // Derive KM from value ('1km' -> 1, etc.)
    let sizeKm;
    switch (selectedCatchmentSize) {
        case '1km': sizeKm = 1; break;
        case '4km': sizeKm = 4; break;
        case '8km': sizeKm = 8; break;
        default: return;  // ← Legal, returns early if something’s wrong
    }
    if (isNaN(sizeKm) || sizeKm <= 0) return;

    const markerLatLng = marker.getLatLng();
    if (!markerLatLng) return;
    const { latDelta: latDeltaHalf, lngDelta: lngDeltaHalf } = getDegChange(sizeKm / 2.0, markerLatLng.lat);
    if (!isFinite(latDeltaHalf) || !isFinite(lngDeltaHalf) || latDeltaHalf <= 0 || lngDeltaHalf <= 0) return;

        const bounds = L.latLngBounds(
      [storeLat - latDeltaHalf, storeLng - lngDeltaHalf],
      [storeLat + latDeltaHalf, storeLng + lngDeltaHalf]
    );
    const boundaryRect = L.rectangle(bounds, GRID_BOUNDARY_STYLE);
    // ===== INSERT HERE =====
    // Tag this grid‐mode rectangle with storeId so toggles can remove it later
   boundaryRect.storeId = storeData.storeId;
storeClickBoundaryLayer.addLayer(boundaryRect);



    // Remove this single boundary on next map click
    map.once('click', clearStoreClickBoundary);
} // ← This is where handleStoreMarkerClick ends



        function clearStoreClickBoundary() {
             if (storeClickBoundaryLayer.getLayers().length > 0) {
                 storeClickBoundaryLayer.eachLayer(layer => {
                     // Remove blinking class cleanly
                     try {
                        const element = layer.getElement();
                        if (element && L.DomUtil.hasClass(element, 'marker-blink')) {
                           L.DomUtil.removeClass(element, 'marker-blink');
                        }
                     } catch(e) {}
                 });
                 storeClickBoundaryLayer.clearLayers();
             }
             // Ensure the map click listener is removed if it was added
             map.off('click', clearStoreClickBoundary);
         }

        // --- Centroid Functions (Grid Mode Only) ---
        function calculateAndAddCentroids() {
            if (currentAnalysisMode !== 'grid') return;
            centroidLayer.clearLayers();
            if (!activeGridLayer || currentGridSize === 'none' || !map.hasLayer(activeGridLayer)) {
                if (areCentroidsVisible) toggleCentroidVisibility(false); // Turn off if grid disappears
                return;
            }

            let pointsInView = getAllDataPoints().filter(p =>
                p && typeof p.lat === 'number' && typeof p.lng === 'number' &&
                !isNaN(p.lat) && !isNaN(p.lng) &&
                map.getBounds().contains([p.lat, p.lng]) &&
                (currentCityFilter === null || (p.city && p.city.toUpperCase() === currentCityFilter) || p.isTestPoint)
            );

            if (pointsInView.length === 0) {
                console.log("No data points in current view to calculate centroids for.");
                return; // No points, no centroids
            }

            let centroidsAdded = 0;
            activeGridLayer.eachLayer(function(gridCell) {
                if (gridCell instanceof L.Rectangle && gridCell.getBounds) {
                    const cellBounds = gridCell.getBounds();
                    const pointsInCell = [];
                    let sumLat = 0;
                    let sumLng = 0;

                    // Optimize point filtering slightly
                    const cellSouth = cellBounds.getSouth();
                    const cellNorth = cellBounds.getNorth();
                    const cellWest = cellBounds.getWest();
                    const cellEast = cellBounds.getEast();

                    for (const point of pointsInView) {
                        // Check coordinates directly (potentially faster than bounds.contains for many points)
                        if (point.lat >= cellSouth && point.lat < cellNorth && point.lng >= cellWest && point.lng < cellEast) {
                            pointsInCell.push(point);
                            sumLat += point.lat;
                            sumLng += point.lng;
                        }
                    }

                    if (pointsInCell.length > 0) {
                        const centroidLat = sumLat / pointsInCell.length;
                        const centroidLng = sumLng / pointsInCell.length;
                        const centroidMarker = L.circleMarker([centroidLat, centroidLng], CENTROID_MARKER_OPTIONS);
                        centroidMarker.bindTooltip(`Points: ${pointsInCell.length}`);
                        centroidLayer.addLayer(centroidMarker);
                        centroidsAdded++;
                    }
                }
            });

            console.log(`Calculated and added ${centroidsAdded} centroids.`);
            // Add layer to map only if visible and centroids were actually added
            if (centroidsAdded > 0 && !map.hasLayer(centroidLayer) && areCentroidsVisible) {
                centroidLayer.addTo(map);
            } else if (centroidsAdded === 0 && map.hasLayer(centroidLayer)) {
                // Remove layer if no centroids were generated but it was previously visible
                map.removeLayer(centroidLayer);
            }
        }

        function toggleCentroidVisibility(show) {
             if (currentAnalysisMode !== 'grid') { // Ensure centroids are only for grid mode
                 areCentroidsVisible = false;
                 if (map.hasLayer(centroidLayer)) map.removeLayer(centroidLayer);
                 centroidLayer.clearLayers();
                 centroidToggleButton.classList.remove('active');
                 centroidToggleButton.textContent = "Show (Boundary Mode)";
                 centroidToggleButton.disabled = true;
                 return;
             }

             areCentroidsVisible = show;
             if (show) {
                 if (activeGridLayer && currentGridSize !== 'none' && map.hasLayer(activeGridLayer)) {
                     calculateAndAddCentroids(); // Recalculate when turned on
                     // Only add to map if centroids were actually calculated
                     if (centroidLayer.getLayers().length > 0 && !map.hasLayer(centroidLayer)) {
                         centroidLayer.addTo(map);
                     }
                     centroidToggleButton.classList.add('active');
                     centroidToggleButton.textContent = "Hide Cell Centroids";
                     centroidToggleButton.disabled = false;
                 } else {
                     // Cannot show if no grid is active
                     areCentroidsVisible = false; // Revert state
                     centroidToggleButton.classList.remove('active');
                     centroidToggleButton.disabled = true;
                     centroidToggleButton.textContent = "Show (No Grid)";
                     if (map.hasLayer(centroidLayer)) map.removeLayer(centroidLayer); // Ensure removed
                     centroidLayer.clearLayers(); // Clear any potential stale data
                 }
             } else {
                 // Hide
                 if (map.hasLayer(centroidLayer)) map.removeLayer(centroidLayer);
                 // Don't clear layers immediately, maybe user toggles back quickly
                 // centroidLayer.clearLayers(); // Can uncomment if memory is a huge concern
                 centroidToggleButton.classList.remove('active');
                 centroidToggleButton.textContent = "Show Cell Centroids";
                 // Disable only if no grid is active, otherwise allow re-enabling
                 centroidToggleButton.disabled = (currentGridSize === 'none' || !activeGridLayer || !map.hasLayer(activeGridLayer));
             }
        }


        // --- UI Update Functions ---
        function setActiveCityButton(clickedButton) {
            cityButtons.forEach(btn => btn.classList.remove('active'));
            if (clickedButton) {
                 clickedButton.classList.add('active');
            }
         }

        function focusOnCity(button) {
             clearAnalysisResults(); clearStoreClickBoundary(); storeSearchFeedback.textContent = ''; // Clear search feedback

             const lat = parseFloat(button.getAttribute('data-lat'));
             const lng = parseFloat(button.getAttribute('data-lng'));
             const cityDataAttr = button.getAttribute('data-city');
             const cityNameToFilter = cityDataAttr ? cityDataAttr.toUpperCase() : null;
             const cityDisplayName = button.textContent || "Selected City"; // Get display name

             let filterChanged = false;
             canonicalView = { lat: lat, lng: lng, zoom: CITY_ZOOM }; // Update canonical view

             if (currentCityFilter !== cityNameToFilter) {
                 console.log(`Changing city filter from ${currentCityFilter} to ${cityNameToFilter}`);
                 currentCityFilter = cityNameToFilter;
                 filterChanged = true;
             }

             setActiveCityButton(button);
             if(sidebarTitle) sidebarTitle.textContent = cityDisplayName; // Update sidebar title

             if (!isNaN(lat) && !isNaN(lng)) {
                 map.flyTo([lat, lng], CITY_ZOOM, { animate: true, duration: FLY_DURATION });
                 // Set flag to regenerate grid *after* flyTo finishes (handled in moveend)
                 if (currentAnalysisMode === 'grid' && currentGridSize !== 'none') {
                     needsGridRegeneration = true;
                 } else {
                     needsGridRegeneration = false;
                 }
             } else {
                 console.error("Invalid coordinates for city:", cityDisplayName);
                 needsGridRegeneration = false; // Don't regenerate if flyTo failed
             }
        }

        function showIndiaOverview() {
             clearAnalysisResults(); clearStoreClickBoundary(); storeSearchFeedback.textContent = ''; // Clear search feedback

             let filterChanged = false;
             canonicalView = { lat: INDIA_CENTER[0], lng: INDIA_CENTER[1], zoom: INDIA_ZOOM }; // Update canonical view

             if (currentCityFilter !== null) {
                 console.log(`Changing city filter from ${currentCityFilter} to null (India View)`);
                 currentCityFilter = null;
                 filterChanged = true;
             }

             setActiveCityButton(null); // Deactivate city buttons
             if(sidebarTitle) sidebarTitle.textContent = "India Overview"; // Update sidebar title

             map.flyTo(INDIA_CENTER, INITIAL_ZOOM, { animate: true, duration: FLY_DURATION });

             // Set flag to regenerate grid *after* flyTo finishes (handled in moveend)
             if (currentAnalysisMode === 'grid' && currentGridSize !== 'none') {
                 needsGridRegeneration = true;
             } else {
                 needsGridRegeneration = false;
             }
        }

        // NEW: Function to update visibility of AD layers and legend
        function updateADLayerVisibility() {
            if (atlCheckbox.checked) map.addLayer(atlLayer);
            else map.removeLayer(atlLayer);

            if (facadeCheckbox.checked) map.addLayer(facadeLayer);
            else map.removeLayer(facadeLayer);

            if (bannerCheckbox.checked) map.addLayer(bannerLayer);
            else map.removeLayer(bannerLayer);

            // Update legend visibility based on whether any AD layer is currently visible
            const anyADVisible = map.hasLayer(atlLayer) || map.hasLayer(facadeLayer) || map.hasLayer(bannerLayer);
            retailLegend.style.display = anyADVisible ? 'block' : 'none';

            // Also update analysis button states as visibility affects analysis readiness
            updateAnalysisButtonStates();
        }

        // NEW: Function to update the state of analysis and boundary plot buttons
        function updateAnalysisButtonStates() {
            const anyADLayerHasMarkersAndIsVisible = areAnyADLayersVisibleAndLoaded();

            // Analyze Store Coverage Button
            analyzeStoreCoverageButton.disabled = !isStoreDataLoaded ||
                                                 (currentAnalysisMode === 'grid' && (currentGridSize === 'none' || !activeGridLayer || !map.hasLayer(activeGridLayer) || !anyADLayerHasMarkersAndIsVisible)) ||
                                                 (currentAnalysisMode === 'boundary' && (boundaryLayer.getLayers().length === 0 || !anyADLayerHasMarkersAndIsVisible));

            // Plot Boundaries Button
            const anyBoundarySizeSelected = Array.from(boundaryCatchmentCheckboxes).some(cb => cb.checked);
            plotBoundariesButton.disabled = currentAnalysisMode !== 'boundary' ||
                                            !anyBoundarySizeSelected ||
                                            !anyADLayerHasMarkersAndIsVisible; // Cannot plot if no stores loaded or visible
        }

        function updateBoundaryHeatmapVisibility() {
            const heatmapSelected = Array.from(boundaryCatchmentCheckboxes)
                .some(cb => cb.checked && cb.value === 'heatmap');
            if (heatmapSelected) {
                showHeatmapLayer();
            } else if (heatmapLayer && map.hasLayer(heatmapLayer)) {
                map.removeLayer(heatmapLayer);
                heatmapLayer = null;
            }
        }

        // --- Grid Summary Calculation (Grid Mode Only) ---
        function calculateAndDisplayGridSummary(values) {
            if (currentAnalysisMode !== 'grid') {
                 gridSummaryContainer.innerHTML = '<div class="placeholder">N/A in Boundary Mode</div>';
                 currentGridValues = []; // Clear grid values
                 processDataButton.disabled = true; // Disable copy button
                 return;
            }

            currentGridValues = values ? [...values] : []; // Store a copy
            currentGridValues.sort((a, b) => b - a); // Sort descending for percentile calculation

            if (currentGridValues.length === 0 || currentGridSize === 'none') {
                 gridSummaryContainer.innerHTML = placeholderSummary; // Show placeholder
                 processDataButton.disabled = true; // Disable copy button
                 return;
            }

            const totalCount = currentGridValues.length;
            let sumOrdersTotal = currentGridValues.reduce((acc, val) => acc + val, 0);

            // Prevent division by zero or calculations on negligible totals
            if (sumOrdersTotal < 1e-9) {
                gridSummaryContainer.innerHTML = `<h3>Grid Summary</h3><table id="grid-summary-table"><tbody>
                    <tr><td>Cells for 25% Orders</td><td>0</td></tr>
                    <tr><td>Cells for 50% Orders</td><td>0</td></tr>
                    <tr><td>Cells for 75% Orders</td><td>0</td></tr>
                    <tr><td>Total Cells</td><td>${totalCount}</td></tr>
                    <tr><td>Total Orders in Grid</td><td>${sumOrdersTotal.toFixed(2)}</td></tr>
                </tbody></table>`;
                processDataButton.disabled = false; // Enable copy even if total is zero
                return;
            }

            let count25 = 0, count50 = 0, count75 = 0;
            let sumForThreshold = 0;
            const target25 = 0.25 * sumOrdersTotal;
            const target50 = 0.50 * sumOrdersTotal;
            const target75 = 0.75 * sumOrdersTotal;

            for (let i = 0; i < totalCount; i++) {
                 const currentValue = currentGridValues[i];
                 sumForThreshold += currentValue;
                 if (count25 === 0 && sumForThreshold >= target25) count25 = i + 1;
                 if (count50 === 0 && sumForThreshold >= target50) count50 = i + 1;
                 if (count75 === 0 && sumForThreshold >= target75) {
                     count75 = i + 1;
                     break; // Optimization: stop once 75% is reached
                 }
            }

             // Handle cases where even the full sum doesn't reach the target (shouldn't happen with >0 total)
            if (count25 === 0 && totalCount > 0) count25 = totalCount;
            if (count50 === 0 && totalCount > 0) count50 = totalCount;
            if (count75 === 0 && totalCount > 0) count75 = totalCount;

            const thresholdForSummary = (currentGridSize === '1km') ? GRID_1KM_THRESHOLD : GRID_TOOLTIP_THRESHOLD;
            const operatorForSummary = (currentGridSize === '1km') ? '≥' : '>';

            let tableHtml = `<h3>Grid Summary</h3><table id="grid-summary-table"><tbody>
                <tr><td>Cells for 25% Orders</td><td>${count25}</td></tr>
                <tr><td>Cells for 50% Orders</td><td>${count50}</td></tr>
                <tr><td>Cells for 75% Orders</td><td>${count75}</td></tr>
                <tr><td>Total Cells (${operatorForSummary} ${thresholdForSummary.toFixed(1)})</td><td>${totalCount}</td></tr>
                <tr><td>Total Orders in Grid</td><td>${sumOrdersTotal.toFixed(2)}</td></tr>
            </tbody></table>`;

            gridSummaryContainer.innerHTML = tableHtml;
            processDataButton.disabled = false; // Enable copy button
        }


        // --- Clear Data Function (Handles Both Modes + Test Points) ---
        function clearRightSidebarData() {
            console.log("Clearing displayed data (grid/boundaries/summary/analysis/test points).");
            clearTestPoints(); // Clear test points and update their buttons

            if (activeGridLayer && map.hasLayer(activeGridLayer)) {
                 map.removeLayer(activeGridLayer);
                 activeGridLayer = null;
            }
            clearBoundaries(); // Clear boundary layers and update buttons
            calculateAndDisplayGridSummary([]); // Clear summary table
            clearAnalysisResults(); // Clear analysis table/slider/highlights
            clearStoreClickBoundary(); // Clear any temporary store click boundary

            // Reset grid toggle to 'None' and trigger its handler
            const noneRadio = document.getElementById('grid-none');
            if (noneRadio && !noneRadio.checked) {
                 noneRadio.checked = true;
                 // Manually trigger the change handler logic *without* map interaction flags
                 handleGridToggle('none', false);
            } else {
                 // If 'None' was already selected, ensure buttons are still disabled
                 updateAnalysisButtonStates(); // Re-evaluate button states
                 processDataButton.disabled = true;
            }

            if (areCentroidsVisible) {
                 toggleCentroidVisibility(false); // Hide centroids
            }

            // Visual feedback for the button
            const originalText = eraseDataButton.textContent; // Store original text
            eraseDataButton.textContent = "Cleared!";
            eraseDataButton.disabled = true;
            setTimeout(() => {
                 eraseDataButton.textContent = originalText; // Restore original text
                 eraseDataButton.disabled = false; // Re-enable
            }, 1200);
        }


        // --- Grid/Catchment Size Toggling (Handles Both Modes) ---
        async function handleGridToggle(selectedValue, triggeredByMoveEnd = false) {
             console.log(`Grid toggle changed to: ${selectedValue}, Triggered by move: ${triggeredByMoveEnd}`);
             clearAnalysisResults(); // Clear previous analysis results
             clearStoreClickBoundary(); // Clear any store click boundary
             clearBoundaries(); // Clear plotted boundaries (relevant for boundary mode too)

             // Prevent multiple regenerations if triggered rapidly
             if (isRegenerationInProgress) {
                 console.log("Grid regeneration already in progress, skipping.");
                 return;
             }
             isRegenerationInProgress = true; // Set flag

             currentGridSize = selectedValue; // Update global state

             // --- UI Updates (Immediate) ---
             // Handle centroid button state (always update regardless of mode)
             if (areCentroidsVisible) {
                 if (map.hasLayer(centroidLayer)) map.removeLayer(centroidLayer); // Hide visually
                 // Don't clear layer data yet, just hide
             }
             centroidToggleButton.disabled = true; // Disable while processing
             centroidToggleButton.classList.remove('active'); // Remove active state
             centroidToggleButton.textContent = "Processing...";

             // Clear existing grid layer from map if present
             if (activeGridLayer && map.hasLayer(activeGridLayer)) {
                 map.removeLayer(activeGridLayer);
                 activeGridLayer = null; // Clear reference
             }
            // Clear heatmap layer if present
            if (heatmapLayer && map.hasLayer(heatmapLayer)) {
                map.removeLayer(heatmapLayer);
                heatmapLayer = null;
            }

            // If selected is heatmap, skip grid logic
            if (selectedValue === 'heatmap') {
                showHeatmapLayer();
                document.getElementById('grid-summary-container').style.display = 'none';
                document.getElementById('btn-toggle-centroids').style.display = 'none';
                isRegenerationInProgress = false;
                updateAnalysisButtonStates(); // Update analysis button state for heatmap
                return;
            } else {
                document.getElementById('grid-summary-container').style.display = 'block'; // Make sure it's visible again
                document.getElementById('btn-toggle-centroids').style.display = 'block';
            }


             // Reset grid summary and disable related buttons immediately
             currentGridValues = [];
             calculateAndDisplayGridSummary(currentGridValues);
             processDataButton.disabled = true;
             // analyzeStoreCoverageButton.disabled = true; // This will be handled by updateAnalysisButtonStates()
             copyStoreCoverageButton.disabled = true;  // Analysis needs to run first

             // Update Boundary mode button state - will be handled by updateAnalysisButtonStates
             // plotBoundariesButton.disabled = currentAnalysisMode !== 'boundary' || selectedValue === 'none' || !areRetailStoresVisible;

             // --- Grid Generation (Only in Grid Mode) ---
             if (currentAnalysisMode === 'grid' && selectedValue !== 'none') {
                 const sizeKm = parseInt(selectedValue.replace('km', ''), 10); // Derive KM from value

                 if (!isNaN(sizeKm) && sizeKm > 0) {
                     try {
                         // If not triggered by map move, ensure we are at the canonical view
                         // This prevents regenerating grid for an intermediate pan/zoom state
                         if (!triggeredByMoveEnd) {
                             console.log("Setting view to canonical before grid generation");
                             map.setView([canonicalView.lat, canonicalView.lng], canonicalView.zoom, { animate: false, noMoveStart: true });
                             await new Promise(resolve => setTimeout(resolve, 50)); // Short delay for view to settle
                         }

                         // Double-check state hasn't changed during async operations/delays
                         if (currentGridSize !== selectedValue || currentAnalysisMode !== 'grid') {
                             console.log("State changed during grid toggle, aborting generation.");
                             isRegenerationInProgress = false; showLoader(false); return;
                         }

                         console.log(`Generating grid for ${sizeKm}km...`);
                         const { layer, data } = await generateGridLayer(sizeKm);

                         // Final check after generation completes
                         if (currentGridSize !== selectedValue || currentAnalysisMode !== 'grid') {
                             console.log("State changed *after* grid generation, discarding results.");
                             isRegenerationInProgress = false; showLoader(false); return;
                         }

                         activeGridLayer = layer; // Store the new layer
                         calculateAndDisplayGridSummary(data); // Update summary with new data

                         if (activeGridLayer && data.length > 0) {
                             map.addLayer(activeGridLayer); // Add new grid to map
                             centroidToggleButton.disabled = false; // Enable centroid button
                             processDataButton.disabled = false; // Enable copy grid data button
                             // Enable analysis only if stores are loaded and visible - now handled by updateAnalysisButtonStates

                             // Update centroid button text based on visibility state
                             if (areCentroidsVisible) {
                                 calculateAndAddCentroids(); // Recalculate and show if needed
                                 centroidToggleButton.textContent = "Hide Cell Centroids";
                                 centroidToggleButton.classList.add('active');
                             } else {
                                 centroidToggleButton.textContent = "Show Cell Centroids";
                                 centroidToggleButton.classList.remove('active');
                             }
                         } else {
                             // Grid generated but was empty or errored
                             console.log("Grid generated but is empty or invalid.");
                             centroidToggleButton.disabled = true;
                             centroidToggleButton.textContent = "Show (No Grid)";
                             processDataButton.disabled = true;
                             // analyzeStoreCoverageButton.disabled = true; // Handled by updateAnalysisButtonStates
                             if (areCentroidsVisible) toggleCentroidVisibility(false); // Ensure off
                         }

                     } catch (error) {
                         console.error("Error during grid generation or processing:", error);
                         showLoader(false); // Ensure loader is hidden on error
                         calculateAndDisplayGridSummary([]); // Clear summary
                         centroidToggleButton.disabled = true;
                         centroidToggleButton.textContent = "Show (Error)";
                         // analyzeStoreCoverageButton.disabled = true; // Handled by updateAnalysisButtonStates
                         processDataButton.disabled = true;
                         if (areCentroidsVisible) toggleCentroidVisibility(false);
                     }
                 } else {
                     // Invalid size derived (e.g., 'none' or unexpected value)
                     showLoader(false); // Hide loader if it was shown
                     console.log("Invalid grid size selected.");
                     centroidToggleButton.disabled = true;
                     centroidToggleButton.textContent = "Show (Invalid)";
                     // analyzeStoreCoverageButton.disabled = true; // Handled by updateAnalysisButtonStates
                     processDataButton.disabled = true;
                     if (areCentroidsVisible) toggleCentroidVisibility(false);
                 }
             } else {
                 // --- Non-Grid Mode or 'None' selected ---
                 showLoader(false); // Ensure loader is off
                 console.log("Grid size set to 'none' or not in grid mode.");
                 if (activeGridLayer && map.hasLayer(activeGridLayer)) {
                     map.removeLayer(activeGridLayer); // Ensure removed
                     activeGridLayer = null;
                 }
                 calculateAndDisplayGridSummary([]); // Clear summary
                 centroidToggleButton.disabled = true; // Disable centroids
                 centroidToggleButton.textContent = currentAnalysisMode === 'grid' ? "Show (No Grid)" : "Show (Boundary Mode)";
                 processDataButton.disabled = true; // Disable grid copy
                 // analyzeStoreCoverageButton.disabled = true; // Handled by updateAnalysisButtonStates
                 if (areCentroidsVisible) toggleCentroidVisibility(false); // Ensure centroids off

                 // Re-evaluate boundary plot button state (might be enabled if size != 'none' and stores visible)
                 // if (currentAnalysisMode === 'boundary') {
                 //    plotBoundariesButton.disabled = selectedValue === 'none' || !areAnyADLayersVisibleAndLoaded(); // Handled by updateAnalysisButtonStates
                 // }
             }
             updateAnalysisButtonStates(); // Call after all layer changes
             isRegenerationInProgress = false; // Release flag
             console.log("Grid toggle processing finished.");
         }

        // --- Plot Boundaries (Boundary Mode Only) ---
        function plotBoundaries() {
             if (currentAnalysisMode !== 'boundary') return; // Only in boundary mode
             clearBoundaries(); // Clear previous boundaries
             clearAnalysisResults(); // Clear previous analysis
             clearStoreClickBoundary(); // Clear temporary click boundaries

             const selectedSizes = Array.from(boundaryCatchmentCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
             if (selectedSizes.length === 0) {
                 alert("Please select at least one catchment size before plotting boundaries.");
                 plotBoundariesButton.disabled = true;
                 return;
             }

             if (!areAnyADLayersVisibleAndLoaded()) { // Check if any AD layers are visible
                 alert("Please enable at least one AD Type checkbox and ensure some are visible to plot boundaries.");
                 return;
             }

            const includesHeatmap = selectedSizes.includes('heatmap');
            const sizeKmValues = selectedSizes
                .filter(val => val !== 'heatmap')
                .map(val => {
                    switch(val) {
                        case '1km': return 1;
                        case '4km': return 4;
                        case '8km': return 8;
                        default:
                            console.error('Invalid catchment size for plotting:', val);
                            return NaN;
                    }
                })
                .filter(num => !isNaN(num) && num > 0);
            if (sizeKmValues.length === 0 && !includesHeatmap) return;

            if (includesHeatmap) {
                showHeatmapLayer();
            } else if (heatmapLayer && map.hasLayer(heatmapLayer)) {
                map.removeLayer(heatmapLayer);
                heatmapLayer = null;
            }

             showLoader(true);
             let plottedCount = 0;
             const currentMapBounds = map.getBounds();

             // Iterate through all markers from *all* AD layers to find visible ones
             allRetailMarkersLayer.eachLayer(marker => { // Use the combined layer for iterating all markers
                 const markerLatLng = marker.getLatLng();
                 const storeData = marker.storeData;

                 // Check if the marker's *specific layer* is currently on the map AND if the marker itself is within view
                 let isMarkerLayerVisible = false;
                 const typeLower = (storeData.type || '').toLowerCase();
                if (typeLower === 'atl' && map.hasLayer(atlLayer)) isMarkerLayerVisible = true;
else if ((typeLower === 'fc' || typeLower === 'gate facade') && map.hasLayer(facadeLayer)) isMarkerLayerVisible = true;
else if (typeLower === 'retailstore' && map.hasLayer(bannerLayer)) isMarkerLayerVisible = true;

                const storeToggle = document.getElementById(`toggle-${storeData.storeId}`);

                if (isMarkerLayerVisible && (!storeToggle || storeToggle.checked) && markerLatLng && currentMapBounds.contains(markerLatLng)) {
                    // Ensure marker has valid data needed for the boundary
                    if (!storeData || !storeData.storeId || !markerLatLng) return;

                     const centerLat = markerLatLng.lat;
                     const centerLng = markerLatLng.lng;

                     sizeKmValues.forEach(sizeKm => {
                         const halfKm = sizeKm / 2.0;
                         const { latDelta: latDeltaHalf, lngDelta: lngDeltaHalf } = getDegChange(halfKm, centerLat);

                         // Check for valid delta calculation
                         if (!isFinite(latDeltaHalf) || !isFinite(lngDeltaHalf) || latDeltaHalf <= 0 || lngDeltaHalf <= 0) {
                            console.warn(`Could not calculate valid boundary for store ${storeData.storeId}`);
                            return;
                         }

                         const sw = [centerLat - latDeltaHalf, centerLng - lngDeltaHalf];
                         const ne = [centerLat + latDeltaHalf, centerLng + lngDeltaHalf];
                         const bounds = L.latLngBounds(sw, ne);

                         // Create the boundary rectangle
                         const boundaryRect = L.rectangle(bounds, BLINKING_BOUNDARY_STYLE);
                         boundaryRect.storeId = storeData.storeId; // Attach store ID
                         boundaryRect.boundaryBounds = bounds; // Attach bounds for analysis
                         boundaryLayer.addLayer(boundaryRect);

                        // Apply blinking class
                        try {
                           const element = boundaryRect.getElement();
                           if (element) L.DomUtil.addClass(element, 'marker-blink');
                        } catch(e) {
                            console.warn(`Could not apply blinking class to boundary for store ${storeData.storeId}:`, e);
                        }

                         plottedCount++;
                     });
                }
            });

             showLoader(false);
             updateAnalysisButtonStates(); // Update analysis button state after plotting
             copyStoreCoverageButton.disabled = true; // Analysis hasn't run yet

             if (plottedCount === 0 && areAnyADLayersVisibleAndLoaded()) { // Check if stores were visible but none in map view
                 alert("No ADs are currently visible in the map view to plot boundaries for.");
             }
             console.log(`Plotted ${plottedCount} boundaries.`);
        }

        function clearBoundaries() {
             if (boundaryLayer.getLayers().length > 0) {
                console.log("Clearing boundaries...");
                 boundaryLayer.eachLayer(layer => {
                    // Cleanly remove blinking class
                    try {
                        const element = layer.getElement();
if (element && L.DomUtil.hasClass(element, 'marker-blink')) {
    L.DomUtil.removeClass(element, 'marker-blink');
}
                    } catch(e) {}
                 });
                 boundaryLayer.clearLayers();
                 updateAnalysisButtonStates(); // Update analysis button state after clearing
                 copyStoreCoverageButton.disabled = true; // Analysis results are cleared
             }
             if (heatmapLayer && map.hasLayer(heatmapLayer)) {
                map.removeLayer(heatmapLayer);
                heatmapLayer = null;
             }
        }


        // --- Store Coverage Analysis Functions ---
        // Run analysis on REAL data + any TEST data
        function runAnalysis() {
            clearAnalysisResults(); // Clear previous results display
            clearStoreClickBoundary(); // Clear temporary marker boundary
            isShowingTestResults = false; // Set flag for combined data analysis
            const allData = getAllDataPoints(); // Combine actual and test data

            if (allData.length === 0) {
                alert("No data points (actual or test) available to analyze.");
                return;
            }

            console.log(`Running analysis with combined data (${allData.length} points)`);
            if (currentAnalysisMode === 'grid') {
                 analyzeGridCoverage(allData);
            } else if (currentAnalysisMode === 'boundary') {
                 analyzeBoundaryCoverage(allData);
            } else {
                 console.error("Unknown analysis mode:", currentAnalysisMode);
            }
         }

        // Run analysis on TEST data ONLY
        function runTestAnalysis() {
            clearAnalysisResults(); // Clear previous results display
            clearStoreClickBoundary(); // Clear temporary marker boundary

            if (testDataPoints.length === 0) {
                 alert("No test points generated to analyze.");
                 // Ensure button is disabled if no test points exist
                 analyzeTestPointsButton.disabled = true;
                 return;
            }

            isShowingTestResults = true; // Set flag for test-only analysis
            console.log(`Running analysis with TEST data ONLY (${testDataPoints.length} points)`);

            if (currentAnalysisMode === 'grid') {
                 analyzeGridCoverage(testDataPoints); // Pass only test points
            } else if (currentAnalysisMode === 'boundary') {
                 analyzeBoundaryCoverage(testDataPoints); // Pass only test points
            } else {
                 console.error("Unknown analysis mode for test analysis:", currentAnalysisMode);
            }
        }

        // Modified to accept data source and use it for summation
        function analyzeGridCoverage(dataSource) {
            const analysisType = isShowingTestResults ? 'TEST' : 'Combined';
            console.log(`Starting Grid Coverage Analysis using ${analysisType} data...`);
            analysisResultsTitle.textContent = `Grid Analysis Results (${analysisType})`; // Update title immediately

            if (currentGridSize === 'none' || !activeGridLayer || !map.hasLayer(activeGridLayer)) {
                storeCoverageTableContainer.innerHTML = '<div class="placeholder">Error: No grid active. Select a catchment size.</div>';
                storeCoverageAnalysisDiv.style.display = 'block';
                updateAnalysisButtonStates(); // Ensure correct state
                copyStoreCoverageButton.disabled = true;
                updateHighlightedGrid(0); // Clear highlights
                return;
            }
            if (!areAnyADLayersVisibleAndLoaded()) {
                storeCoverageTableContainer.innerHTML = '<div class="placeholder">Error: Enable at least one AD Type checkbox first.</div>';
                storeCoverageAnalysisDiv.style.display = 'block';
                updateAnalysisButtonStates(); // Ensure correct state
                copyStoreCoverageButton.disabled = true;
                updateHighlightedGrid(0);
                return;
            }

            showLoader(true);
            const tempCoveredCellsMap = new Map();
            let processedCells = 0;

            // Collect all visible markers from all AD layers
            const visibleStores = [];
            if (map.hasLayer(atlLayer)) atlLayer.eachLayer(marker => visibleStores.push(marker));
            if (map.hasLayer(facadeLayer)) facadeLayer.eachLayer(marker => visibleStores.push(marker));
            if (map.hasLayer(bannerLayer)) bannerLayer.eachLayer(marker => visibleStores.push(marker));
            
            // Further filter to only include stores currently in the map bounds
            const visibleStoresInBounds = visibleStores.filter(marker => map.getBounds().contains(marker.getLatLng()));

            if (visibleStoresInBounds.length === 0) {
                 console.log("No ADs are visible in the current map view for analysis.");
                 storeCoverageTableContainer.innerHTML = '<div class="placeholder">No ADs visible in map view to analyze coverage for.</div>';
                 storeCoverageAnalysisDiv.style.display = 'block';
                 updateAnalysisButtonStates(); // Ensure correct state
                 copyStoreCoverageButton.disabled = true;
                 updateHighlightedGrid(0);
                 showLoader(false);
                 return;
            }

            activeGridLayer.eachLayer(cell => {
                // Check if it's a valid grid cell rectangle with bounds
                if (cell instanceof L.Rectangle && cell.getBounds && typeof cell._orderValue === 'number') { // cell._orderValue is based on *all* data always
                    processedCells++;
                    const cellBounds = cell.getBounds();
                    const cellId = cell._leaflet_id;
                    let coveringStoreIds = [];

                    // Check which visible stores cover this cell
                    for (const marker of visibleStoresInBounds) { // Use pre-filtered visible stores in bounds
                        const markerLatLng = marker.getLatLng();
                        const storeData = marker.storeData;
                        // Check contains and validity
                        if (storeData && storeData.storeId && markerLatLng && cellBounds.contains(markerLatLng)) {
                            coveringStoreIds.push(storeData.storeId);
                        }
                    }

                    if (coveringStoreIds.length > 0) {
                        // Calculate sum ONLY from the relevant dataSource (passed into this function) within this specific cell
                        let sumOrdersInCellFromSource = 0;
                        const cellSouth = cellBounds.getSouth();
                        const cellNorth = cellBounds.getNorth();
                        const cellWest = cellBounds.getWest();
                        const cellEast = cellBounds.getEast();

                        for(const point of dataSource) {
                             // Check point validity and if it falls within the cell bounds
                             if (point && typeof point.orders === 'number' && !isNaN(point.orders) &&
                                 point.lat >= cellSouth && point.lat < cellNorth &&
                                 point.lng >= cellWest && point.lng < cellEast) {
                                 sumOrdersInCellFromSource += point.orders;
                             }
                        }

                        // Only store the cell result if the *specific data source* contributed orders > 0 to it
                        if(sumOrdersInCellFromSource > 1e-9) { // Use epsilon for float comparison
                            const uniqueStoreIds = [...new Set(coveringStoreIds)]; // Remove duplicates if any
                            // Store the calculated sum from the specific source, NOT the grid's total _orderValue
                            tempCoveredCellsMap.set(cellId, {
                                value: sumOrdersInCellFromSource,
                                cell: cell, // Keep reference to original cell for highlighting
                                storeIds: uniqueStoreIds
                            });
                        }
                    }
                }
            });

            // Store results in the main variable for display/copy, sorted by the calculated value
            coveredGridCellsData = Array.from(tempCoveredCellsMap.values()).sort((a, b) => b.value - a.value);
            showLoader(false);
            console.log(`Processed ${processedCells} grid cells. Found ${coveredGridCellsData.length} cells covered by stores with orders from ${analysisType} data.`);
            displayAnalysisResults(); // Update the UI table and slider
        }

        // Modified to accept data source
        function analyzeBoundaryCoverage(dataSource) {
             const analysisType = isShowingTestResults ? 'TEST' : 'Combined';
             console.log(`Starting Boundary Coverage Analysis using ${analysisType} data...`);
             analysisResultsTitle.textContent = `Boundary Analysis Results (${analysisType})`; // Update title

             const boundaries = boundaryLayer.getLayers();
             if (boundaries.length === 0) {
                 storeCoverageTableContainer.innerHTML = '<div class="placeholder">Error: Plot boundaries first using the button above.</div>';
                 storeCoverageAnalysisDiv.style.display = 'block';
                 updateAnalysisButtonStates(); // Ensure correct state
                 copyStoreCoverageButton.disabled = true;
                 return;
             }
            if (!areAnyADLayersVisibleAndLoaded()) {
                storeCoverageTableContainer.innerHTML = '<div class="placeholder">Error: Enable at least one AD Type checkbox first.</div>';
                storeCoverageAnalysisDiv.style.display = 'block';
                updateAnalysisButtonStates(); // Ensure correct state
                copyStoreCoverageButton.disabled = true;
                return;
            }


             showLoader(true);
             boundaryAnalysisResults = []; // Clear previous results
             const pointOverlapMap = new Map(); // Map: pointIndex -> [overlappingBoundaryRect1, boundaryRect2, ...]
             let validPointsAnalyzed = 0;

             // --- Phase 1: Find which boundaries cover each data point ---
             dataSource.forEach((point, pointIndex) => {
                 // Ensure point is valid and has orders > 0
                 if (point && typeof point.lat === 'number' && typeof point.lng === 'number' && typeof point.orders === 'number' &&
                     !isNaN(point.lat) && !isNaN(point.lng) && !isNaN(point.orders) && point.orders > 1e-9) // Use epsilon
                 {
                     validPointsAnalyzed++;
                     const pointLatLng = [point.lat, point.lng];
                     let overlaps = []; // Store overlaps for *this* point
                     boundaries.forEach(boundaryRect => {
                         // Check if the boundary is valid and contains the point
                         if (boundaryRect.boundaryBounds && boundaryRect.boundaryBounds.contains(pointLatLng)) {
                             overlaps.push(boundaryRect); // Add the boundary object itself
                         }
                     });
                     // If this point was covered by one or more boundaries, record it
                     if (overlaps.length > 0) {
                        pointOverlapMap.set(pointIndex, overlaps);
                     }
                 }
             });

             console.log(`Found ${pointOverlapMap.size} points (out of ${validPointsAnalyzed} valid points) covered by ${boundaries.length} boundaries.`);

             // --- Phase 2: Distribute order value among overlapping boundaries ---
             const boundaryOrderSum = new Map(); // Map: boundaryLeafletId -> { storeId: "...", orders: 0 }

             pointOverlapMap.forEach((overlappingBoundaries, pointIndex) => {
                 const orderValue = dataSource[pointIndex].orders; // Get order value from the specific dataSource
                 const overlapCount = overlappingBoundaries.length;

                 if (overlapCount > 0) {
                     const share = orderValue / overlapCount; // Calculate share per boundary
                     overlappingBoundaries.forEach(boundaryRect => {
                         const boundaryId = boundaryRect._leaflet_id; // Unique ID for this boundary rectangle
                         const storeId = boundaryRect.storeId; // Get the associated store ID

                         // Initialize if first time seeing this boundary
                         if (!boundaryOrderSum.has(boundaryId)) {
                             boundaryOrderSum.set(boundaryId, { storeId: storeId, orders: 0 });
                         }
                         // Add the share to this boundary's total
                         boundaryOrderSum.get(boundaryId).orders += share;
                     });
                 }
             });

             // --- Phase 3: Format results for display ---
             let tempResults = [];
             boundaryOrderSum.forEach((data, id) => {
                // Filter out results with negligible orders
                if (data.orders > 1e-9) {
                    tempResults.push({ storeId: data.storeId, value: data.orders });
                }
             });

             // Store final sorted results in the main variable
             boundaryAnalysisResults = tempResults
                .sort((a, b) => b.value - a.value) // Sort descending by order value
                .map((item, index) => ({ ...item, rank: index + 1 })); // Add rank

             showLoader(false);
             console.log(`Calculated orders for ${boundaryAnalysisResults.length} boundaries using ${analysisType} data.`);
             displayAnalysisResults(); // Update UI
        }


        // Display function updates title based on flag, handles grid/boundary differences
        function displayAnalysisResults() {
             storeCoverageAnalysisDiv.style.display = 'block'; // Make analysis section visible

             const results = currentAnalysisMode === 'grid' ? coveredGridCellsData : boundaryAnalysisResults;
             const noResults = !results || results.length === 0;
             const resultType = currentAnalysisMode === 'grid' ? 'grid cells' : 'store boundaries';
             const tableHeaderId = currentAnalysisMode === 'grid' ? 'Store ID(s) in Cell' : 'Store ID';
             const analysisTypeText = isShowingTestResults ? '(Test Points Only)' : '(Combined Data)'; // Text based on flag
             const modeText = currentAnalysisMode === 'grid' ? 'Grid' : 'Boundary';

             // Update the main title for the analysis section
             analysisResultsTitle.textContent = `${modeText} Analysis Results ${analysisTypeText}`;

             if (noResults) {
                 storeCoverageTableContainer.innerHTML = `<div class="placeholder">No ${resultType} found ${currentAnalysisMode === 'grid' ? 'covering stores' : 'containing orders'} from the selected data.</div>`;
                 storeCoverageSlider.max = 0;
                 storeCoverageSlider.value = 0;
                 storeCoverageSlider.disabled = true;
                 storeCoverageSliderLabel.textContent = '0';
                 copyStoreCoverageButton.disabled = true;
                 updateHighlightedGrid(0); // Clear any previous highlights
                 updateAnalysisButtonStates(); // Ensure analysis button state is correct
                 analyzeTestPointsButton.disabled = testDataPoints.length === 0; // Re-check test points
                 return;
             }

             // --- Build Table HTML ---
             let tableHTML = `<table id="store-coverage-table"><thead><tr><th>Rank</th><th>${tableHeaderId}</th><th>Orders</th></tr></thead><tbody>`;
             results.forEach((item, index) => {
                 // Format order value for display
                 const displayValue = item.value.toFixed(item.value < 10 ? 2 : (item.value < 100 ? 1 : 0));
                 // Get ID(s) text based on mode
                 const idText = currentAnalysisMode === 'grid'
                               ? (item.storeIds ? item.storeIds.join(', ') : 'N/A') // Handle potential missing storeIds
                               : (item.storeId || 'N/A');
                 // Get rank (already calculated for boundary, use index+1 for grid)
                 const rank = currentAnalysisMode === 'grid' ? index + 1 : item.rank;
                 tableHTML += `<tr><td>${rank}</td><td>${idText}</td><td style="text-align: right;">${displayValue}</td></tr>`; // Align numbers right
             });
             tableHTML += '</tbody></table>';
             storeCoverageTableContainer.innerHTML = tableHTML; // Update table container

             // --- Configure Slider (Grid Mode Only) ---
             if (currentAnalysisMode === 'grid') {
                 storeCoverageSlider.disabled = false;
                 storeCoverageSlider.min = 0; // Allow showing 0 highlights
                 storeCoverageSlider.max = results.length;
                 // Maintain current slider value if possible, otherwise default to max
                 let currentSliderValue = Math.min(parseInt(storeCoverageSlider.value, 10), results.length);
                 if (isNaN(currentSliderValue) || currentSliderValue < 0) { // Ensure value is valid, default to max if not
                    currentSliderValue = results.length;
                 }
                 storeCoverageSlider.value = currentSliderValue; // Set slider position
                 storeCoverageSliderLabel.textContent = currentSliderValue; // Update label
                 storeCoverageSliderContainer.style.display = 'block'; // Show slider
                 updateHighlightedGrid(currentSliderValue); // Highlight based on value
             }
             else { // Boundary Mode - Hide slider
                 storeCoverageSlider.disabled = true;
                 storeCoverageSlider.value = 0;
                 storeCoverageSliderLabel.textContent = '0';
                 storeCoverageSliderContainer.style.display = 'none'; // Hide slider container
                 updateHighlightedGrid(0); // Clear grid highlights (shouldn't be any anyway)
             }

             // Enable copy button now that there are results
             copyStoreCoverageButton.disabled = false;
             updateAnalysisButtonStates(); // Re-enable analysis buttons
             analyzeTestPointsButton.disabled = testDataPoints.length === 0;
        }


        // Highlights top N grid cells based on slider (Grid Mode Only)
        function updateHighlightedGrid(countToShow) {
            // Clear existing highlights first
            if (map.hasLayer(highlightedGridLayer)) {
                 // map.removeLayer(highlightedGridLayer); // Removing/re-adding can cause flicker
                 highlightedGridLayer.clearLayers(); // Prefer clearing
            } else {
                 highlightedGridLayer.clearLayers(); // Ensure it's empty even if not on map
            }


            // Only proceed if in grid mode, count > 0, and results exist
            if (currentAnalysisMode !== 'grid' || countToShow <= 0 || !coveredGridCellsData || coveredGridCellsData.length === 0) {
                 return;
            }

            const cellsToHighlight = coveredGridCellsData.slice(0, countToShow);
            let highlightedCount = 0;
            cellsToHighlight.forEach(item => {
                 const originalCell = item.cell;
                 // Check if the original cell and its bounds are valid
                 if (originalCell && originalCell.getBounds && originalCell.options) {
                     // Create a new rectangle for the highlight overlay
                     const highlightRect = L.rectangle(originalCell.getBounds(), {
                         // Inherit fill color from original cell for context, but use highlight style for border
                         ...HIGHLIGHT_CELL_STYLE, // Uses yellow border defined earlier
                         fillColor: originalCell.options.fillColor, // Keep original fill color
                         fillOpacity: 0.3 // Make highlight slightly more transparent than original
                     });
                     highlightedGridLayer.addLayer(highlightRect);
                     highlightedCount++;
                 } else {
                     console.warn("Skipping highlight for invalid cell data:", item);
                 }
            });

            // Add the layer to the map only if it's not already there and has highlights
            if (highlightedCount > 0 && !map.hasLayer(highlightedGridLayer)) {
                highlightedGridLayer.addTo(map);
            }
            // console.log(`Highlighted ${highlightedCount} grid cells.`);
        }

        // Clear Analysis Results Display and State
        function clearAnalysisResults() {
             console.log("Clearing analysis results display.");
             coveredGridCellsData = []; // Clear grid results data
             boundaryAnalysisResults = []; // Clear boundary results data
             isShowingTestResults = false; // Reset analysis type flag

             // Clear visual highlights
             if (map.hasLayer(highlightedGridLayer)) {
                 // map.removeLayer(highlightedGridLayer); // Flicker issue
                 highlightedGridLayer.clearLayers();
             } else {
                 highlightedGridLayer.clearLayers(); // Ensure empty
             }

             // Reset the analysis display section in the left sidebar
             if (storeCoverageAnalysisDiv) {
                 storeCoverageAnalysisDiv.style.display = 'none'; // Hide the whole section
                 storeCoverageTableContainer.innerHTML = storeCoveragePlaceholder; // Reset table
                 storeCoverageSlider.max = 0; // Reset slider
                 storeCoverageSlider.value = 0;
                 storeCoverageSlider.disabled = true;
                 storeCoverageSliderLabel.textContent = '0';
                 storeCoverageSliderContainer.style.display = 'block'; // Keep container visible but slider disabled
                 analysisResultsTitle.textContent = "Analysis Results"; // Reset title
                 copyStoreCoverageButton.disabled = true; // Disable copy button
             }

             // Reset analysis button states logically
             updateAnalysisButtonStates(); // Re-evaluate button states
             analyzeTestPointsButton.disabled = testDataPoints.length === 0; // Test analysis depends only on test points
        }

        // Copy Analysis Data to Clipboard
        function copyStoreCoverageData() {
            const resultsToCopy = currentAnalysisMode === 'grid' ? coveredGridCellsData : boundaryAnalysisResults;
            const noResults = !resultsToCopy || resultsToCopy.length === 0;

            if (noResults) {
                 // Feedback directly on the button
                 copyStoreCoverageButton.textContent = "No Data!";
                 copyStoreCoverageButton.style.backgroundColor = '#ffc107'; // Yellow warning
                 setTimeout(() => {
                     copyStoreCoverageButton.textContent = "Copy Analysis Data";
                     copyStoreCoverageButton.style.backgroundColor = '#6c757d'; // Restore original color
                 }, 1500);
                 return;
            }

            let tsvString = "";
            // Construct TSV string based on the current analysis mode
            if (currentAnalysisMode === 'grid') {
                 tsvString = "Rank\tStore ID(s)\tOrders\n"; // Header row
                 resultsToCopy.forEach((item, index) => {
                     const valueString = item.value.toString(); // Convert value to string
                     const storeIdString = item.storeIds ? item.storeIds.join(', ') : ''; // Join array, handle undefined
                     tsvString += `${index + 1}\t${storeIdString}\t${valueString}\n`; // Add data row
                 });
            } else { // Boundary Mode
                 tsvString = "Rank\tStore ID\tOrders\n"; // Header row
                 resultsToCopy.forEach(item => {
                     const valueString = item.value.toString();
                     const storeIdString = item.storeId || ''; // Handle undefined
                     tsvString += `${item.rank}\t${storeIdString}\t${valueString}\n`; // Add data row
                 });
            }

            // Use Clipboard API to copy the TSV string
            navigator.clipboard.writeText(tsvString).then(() => {
                 // Success feedback
                 copyStoreCoverageButton.textContent = "Copied!";
                 copyStoreCoverageButton.style.backgroundColor = '#28a745'; // Green success
                 setTimeout(() => {
                     copyStoreCoverageButton.textContent = "Copy Analysis Data";
                     copyStoreCoverageButton.style.backgroundColor = '#6c757d'; // Restore color
                     copyStoreCoverageButton.disabled = noResults; // Keep disabled if there were no results initially
                 }, 1800);
            }).catch(err => {
                 // Error feedback
                 console.error('Failed to copy analysis data: ', err);
                 copyStoreCoverageButton.textContent = "Copy Failed";
                 copyStoreCoverageButton.style.backgroundColor = '#dc3545'; // Red error
                 setTimeout(() => {
                     copyStoreCoverageButton.textContent = "Copy Analysis Data";
                     copyStoreCoverageButton.style.backgroundColor = '#6c757d'; // Restore color
                     copyStoreCoverageButton.disabled = noResults;
                 }, 2000);
            });
        }

        // Handle Switching Between Grid and Boundary Analysis Modes
        function handleAnalysisModeChange(newMode) {
            if (newMode === currentAnalysisMode) return; // No change

            console.log(`Switching analysis mode from ${currentAnalysisMode} to: ${newMode}`);
            currentAnalysisMode = newMode; // Update global state

            // Clear things specific to the previous mode or analysis results
            clearAnalysisResults();
            clearStoreClickBoundary();
            calculateAndDisplayGridSummary([]); // Clear summary (relevant if switching FROM grid)

            // --- UI Adjustments based on NEW mode ---
            if (newMode === 'grid') {
                // Show/Hide UI elements relevant to Grid mode
                plotBoundariesButton.style.display = 'none';   // Hide boundary plot button
                clearCatchmentsButton.style.display = 'none';   // Hide clear button
                catchmentControls.style.display = 'block'; // Show catchment size (used by grid)
                catchmentRadioGroup.style.display = 'block';
                boundaryCatchmentContainer.style.display = 'none';
                heatmapControls.style.display = 'block';   // Show heatmap scale
                gridAnalysisControls.style.display = 'block'; // Show centroid toggle area
                gridSummaryContainer.style.display = 'block'; // Show summary area

                clearBoundaries(); // Remove any plotted boundaries if switching TO grid mode

                // Update centroid button state based on current grid status
                centroidToggleButton.disabled = (currentGridSize === 'none' || !activeGridLayer || !map.hasLayer(activeGridLayer));
                centroidToggleButton.textContent = areCentroidsVisible ? "Hide Cell Centroids" : "Show Cell Centroids";
                if(!centroidToggleButton.disabled && areCentroidsVisible) {
                   centroidToggleButton.classList.add('active');
                } else {
                   centroidToggleButton.classList.remove('active');
                }

                // Potentially regenerate grid if a size was selected
                const selectedGrid = document.querySelector('input[name="grid-toggle"]:checked')?.value;
                if (selectedGrid && selectedGrid !== 'none') {
                    needsGridRegeneration = false; // Don't wait for moveend, trigger now
                    handleGridToggle(selectedGrid, false); // Trigger grid generation/display
                } else {
                    // No grid size selected, ensure buttons are disabled
                    processDataButton.disabled = true;
                    // analyzeStoreCoverageButton.disabled = true; // Handled by updateAnalysisButtonStates
                }

            } else if (newMode === 'boundary') {
                // Show/Hide UI elements relevant to Boundary mode
                plotBoundariesButton.style.display = 'block';  // Show boundary plot button
                clearCatchmentsButton.style.display = 'block'; // Show clear button
                catchmentControls.style.display = 'block'; // Show catchment size (used by boundary)
                catchmentRadioGroup.style.display = 'none';
                boundaryCatchmentContainer.style.display = 'block';
                heatmapControls.style.display = 'none';    // Hide heatmap scale
                gridAnalysisControls.style.display = 'none';  // Hide centroid toggle area
                gridSummaryContainer.style.display = 'none';  // Hide summary area

                // Disable boundary plot button initially if conditions aren't met - handled by updateAnalysisButtonStates

                // Clear grid elements if switching TO boundary mode
                if (activeGridLayer && map.hasLayer(activeGridLayer)) {
                    map.removeLayer(activeGridLayer);
                    activeGridLayer = null;
                }
                if (areCentroidsVisible) { // Hide and disable centroids
                    toggleCentroidVisibility(false);
                }
                centroidToggleButton.disabled = true; // Ensure disabled
                centroidToggleButton.textContent = "Show (Boundary Mode)";
                processDataButton.disabled = true; // Grid copy not applicable

                updateBoundaryHeatmapVisibility();

                // Analysis button depends on whether boundaries are plotted (checked by plotBoundaries/clearBoundaries) - handled by updateAnalysisButtonStates
            }

            // Reset buttons common to both modes after switching
            copyStoreCoverageButton.disabled = true; // Analysis results cleared
            analyzeTestPointsButton.disabled = testDataPoints.length === 0; // Test analysis depends only on test points
            updateAnalysisButtonStates(); // Final call to update button states after mode switch
            console.log("Analysis mode switched. UI updated.");
        }


        // --- Event Listeners ---
        cityButtons.forEach(button => { button.addEventListener('click', () => focusOnCity(button)); });
        indiaViewButton.addEventListener('click', showIndiaOverview);

        // Store Search Listeners
        storeSearchButton.addEventListener('click', findAndHighlightStore);
        storeSearchInput.addEventListener('keypress', function(e) { // Optional: Allow Enter key
            if (e.key === 'Enter') {
                findAndHighlightStore();
                e.preventDefault(); // Prevent potential form submission if wrapped in form
            }
        });

        // Grid Data Copy Listener (Grid Mode Only)
        processDataButton.addEventListener('click', () => {
            if(currentAnalysisMode !== 'grid'){
                console.warn("Attempted to copy grid data when not in grid mode.");
                return;
            }
            // Use the globally stored sorted values
            const numericValuesSortedDesc = [...currentGridValues];
            if(!activeGridLayer || numericValuesSortedDesc.length === 0){
                 processDataButton.textContent = "No Grid Data!";
                 processDataButton.style.backgroundColor = '#ffc107';
                 setTimeout(() => { processDataButton.textContent = "Copy Grid Values"; processDataButton.style.backgroundColor = '#5bc0de'; }, 1500);
                 return;
            }
            const textToCopy=numericValuesSortedDesc.join('\n');
            navigator.clipboard.writeText(textToCopy).then(()=>{
                processDataButton.textContent = "Grid Copied!";
                processDataButton.style.backgroundColor = '#28a745';
                setTimeout(() => { processDataButton.textContent = "Copy Grid Values"; processDataButton.style.backgroundColor = '#5bc0de'; }, 1800);
            }).catch(err=>{
                console.error("Failed to copy grid data:", err);
                processDataButton.textContent = "Copy Failed!";
                processDataButton.style.backgroundColor = '#dc3545';
                setTimeout(() => { processDataButton.textContent = "Copy Grid Values"; processDataButton.style.backgroundColor = '#5bc0de'; }, 2000);
            });
         });

        eraseDataButton.addEventListener('click', clearRightSidebarData);

        // Analysis Mode Change Listener
        analysisModeRadios.forEach(radio => { radio.addEventListener('change', (event) => handleAnalysisModeChange(event.target.value)); });

        // Boundary Plot Listener (Boundary Mode Only)
        plotBoundariesButton.addEventListener('click', plotBoundaries);

        // Grid/Catchment Size Change Listener
        gridToggleRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                needsGridRegeneration = false; // Reset flag, handle directly
                handleGridToggle(event.target.value, false); // Trigger handler
            });
        });

        // Boundary catchment checkbox listener
        boundaryCatchmentCheckboxes.forEach(cb => {
            cb.addEventListener('change', () => {
                updateAnalysisButtonStates();
                updateBoundaryHeatmapVisibility();
            });
        });

        // Heatmap Color Scale Change Listener (Grid Mode Only)
        colorScaleRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                const newMax = parseFloat(event.target.value);
                if (!isNaN(newMax) && newMax > 0 && currentMaxColorValue !== newMax) {
                     console.log(`Changing heatmap max color value to: ${newMax}`);
                     currentMaxColorValue = newMax;
                     // If in grid mode and a grid is active, regenerate it with the new scale
                     if (currentAnalysisMode === 'grid' && currentGridSize !== 'none' && activeGridLayer && map.hasLayer(activeGridLayer)) {
                         needsGridRegeneration = false; // Handle directly
                         clearStoreClickBoundary(); // Clear potential boundary related to old colors
                         handleGridToggle(currentGridSize, false); // Regenerate grid
                     }
                 }
             });
        });

        // AD Type Toggle Listeners (Corrected and updated)
        atlCheckbox.addEventListener('change', updateADLayerVisibility);
        facadeCheckbox.addEventListener('change', updateADLayerVisibility);
        bannerCheckbox.addEventListener('change', updateADLayerVisibility);

        // Centroid Toggle Listener (Grid Mode Only)
        centroidToggleButton.addEventListener('click', () => {
            if(!centroidToggleButton.disabled){ // Check if button is enabled
                 toggleCentroidVisibility(!areCentroidsVisible); // Toggle state
             }
        });

        // Analysis Button Listeners
        analyzeStoreCoverageButton.addEventListener('click', runAnalysis); // Runs analysis on combined data
        analyzeTestPointsButton.addEventListener('click', runTestAnalysis); // Runs analysis on test data only

        // Analysis Slider Listener (Grid Mode Only)
        storeCoverageSlider.addEventListener('input', (event) => {
             if(currentAnalysisMode === 'grid') { // Only relevant for grid mode
                 const count = parseInt(event.target.value, 10);
                 if (!isNaN(count)) {
                    storeCoverageSliderLabel.textContent = count; // Update label
                    updateHighlightedGrid(count); // Update highlighted cells
                 }
             }
        });

        // Analysis Copy Listener
        copyStoreCoverageButton.addEventListener('click', copyStoreCoverageData);

        // Test Point Button Listeners
        generateTestPointsButton.addEventListener('click', generateTestPoints);
        clearTestPointsButton.addEventListener('click', clearTestPoints);
        clearCatchmentsButton.addEventListener('click', () => {
            boundaryCatchmentCheckboxes.forEach(cb => cb.checked = false);
            clearBoundaries();
            updateAnalysisButtonStates();
            updateBoundaryHeatmapVisibility();
        });


        // --- Map move/zoom listeners ---
        let moveEndTimeout;
        map.on('moveend', function(e) {
             // Clear any temporary boundary from a store click
             clearStoreClickBoundary();

             // Check if regeneration is needed (set by city focus/India view)
             if (needsGridRegeneration && currentAnalysisMode === 'grid' && currentGridSize !== 'none') {
                console.log("Moveend triggered grid regeneration.");
                clearAnalysisResults(); // Clear results before regenerating
                needsGridRegeneration = false; // Consume the flag
                // Use a small delay to prevent excessive calls if moveend fires rapidly
                clearTimeout(moveEndTimeout);
                moveEndTimeout = setTimeout(() => {
                    handleGridToggle(currentGridSize, true); // Pass flag indicating it's due to map move
                }, 150); // Adjust delay as needed
             } else if (needsGridRegeneration) {
                 // Reset flag if not in grid mode or no grid size selected
                 needsGridRegeneration = false;
             }

            // Update permanent tooltips visibility based on zoom
             if(currentAnalysisMode === 'grid' && activeGridLayer && map.hasLayer(activeGridLayer)) {
                 const showLabels = map.getZoom() > 13; // Threshold zoom level
                 activeGridLayer.eachLayer(layer => {
                     if (layer.getTooltip()) {
                         if (showLabels && !layer.isTooltipOpen()) {
                             layer.openTooltip();
                         } else if (!showLabels && layer.isTooltipOpen()) {
                             layer.closeTooltip();
                         }
                     } else if (showLabels && layer.bindTooltip && layer._tooltipContent) {
                         // Rebind if tooltip was removed or not initially permanent
                         layer.bindTooltip(layer._tooltipContent, { permanent: true, direction: 'center', className: 'grid-label', opacity: 0.9 });
                         layer.openTooltip();
                     }
                 });
             }
        });


        // --- Initial Page Setup ---
        function initializeApp() {
            console.log("Initializing application...");
            createRetailStoreMarkers(); // Create markers and populate layers

            // Set initial state for buttons and UI elements
            calculateAndDisplayGridSummary([]); // Clear summary initially
            centroidToggleButton.disabled = true;
            centroidToggleButton.textContent = "Show (No Grid)";
            // analyzeStoreCoverageButton.disabled = true; // Handled by updateAnalysisButtonStates
            copyStoreCoverageButton.disabled = true;
            processDataButton.disabled = true;
            plotBoundariesButton.style.display = 'none'; // Hide boundary button initially
            clearCatchmentsButton.style.display = 'none'; // Hide clear button initially
            analyzeTestPointsButton.style.display = 'none'; // Hide test analysis button
            clearTestPointsButton.style.display = 'none'; // Hide clear test button

            // Clear any potential leftover state
            clearAnalysisResults();
            clearStoreClickBoundary();
            clearBoundaries();
            gridSummaryContainer.innerHTML = placeholderSummary; // Set placeholder

            // Set the initial analysis mode and update UI accordingly
            handleAnalysisModeChange('grid'); // Start in Grid mode

            // Ensure canonical view is set
            canonicalView = { lat: INDIA_CENTER[0], lng: INDIA_CENTER[1], zoom: INDIA_ZOOM };

            // Set initial AD layer visibility based on checkbox states (which are checked by default in HTML)
            // This is done by updateADLayerVisibility which is called by createRetailStoreMarkers
            // updateADLayerVisibility(); // Now called inside createRetailStoreMarkers

            console.log("Map and Controls Initialized.");
        }

        // Run initialization when the DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>

</body>
</html>
